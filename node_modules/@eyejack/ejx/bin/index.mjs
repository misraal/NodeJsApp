#!/usr/bin/env node
import { simpleGit } from 'simple-git'

import axios from 'axios'
import chalk from 'chalk'
import CLI from 'clui'
import { exec } from 'child_process'
import figlet from 'figlet'
import fs from 'fs-extra'
import inquirer from 'inquirer'
import open from 'open'
import Preferences from 'preferences'
import util from 'util'

import { getCurrentDirectoryBase } from '../cli/files.mjs'
import { compressFolder } from '../cli/src/utils/zip-helper.mjs'
import { useApi } from '../cli/src/utils/api.mjs'

const Spinner = CLI.Spinner
const BASE_URL = 'https://api.eyejack.xyz'
const EXTERNAL_URL = 'https://eyejack.xyz'
const GH_TEMPLATE_URL = 'https://github.com/eyejackapp/ejx-template-threejs.git'
const CLI_ID = 'xyz.eyejack.ejx'

const kebabCase = string =>
  string
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .replace(/[\s_]+/g, '-')
    .toLowerCase()

const getProjectId = async () => {
  const proj = await fs.readJson('./package.json')
  return proj.name
}

console.log(
  chalk.yellow(
    figlet.textSync('ejx', {
      font: 'Big'
    })
  )
)

const initialiseProject = async projectId => {
  if (!fs.existsSync('.ejx.json')) {
    const config = {
      projectId: projectId,
      remoteProjectId: '',
      workspaceId: ''
    }
    await fs.writeFileSync('.ejx.json', JSON.stringify(config))
  }
}

const createNewProject = callback => {
  var argv = process.argv.slice(2)

  const questions = [
    {
      type: 'input',
      name: 'name',
      message: 'Enter a new for the project:',
      default: argv[1] || getCurrentDirectoryBase(),
      validate: value => {
        if (value.length) {
          return true
        } else {
          return 'Please enter a name for the project'
        }
      }
    },
    {
      type: 'input',
      name: 'description',
      default: argv[2] || null,
      message: 'Optionally enter a description of the project:'
    },
    {
      type: 'input',
      name: 'author',
      default: '',
      message: 'Optionally enter an author of the project:'
    }
  ]

  inquirer.prompt(questions).then(async answers => {
    console.log(chalk.yellow(`Creating new ejx project: ${answers.name}`))
    await simpleGit().clone(GH_TEMPLATE_URL, answers.name)
    const fileName = `./${answers.name}/package.json`
    const file = await fs.readJson(fileName)
    file.name = answers.name
    file.version = '0.0.1'
    file.description = answers.description
    file.author = answers.author
    fs.writeJson(fileName, file, { spaces: 2 }, err => {
      if (err) return console.log(err)
      console.log(
        chalk.yellow(
          `New ejx project created, run 'cd ${answers.name} && npm i && npm run dev'`
        )
      )
    })
    //const prefs = new Preferences('ejx')
    const projectId = kebabCase(answers.name)
    // check for config file `.ejx.json`
    await initialiseProject(projectId)
  })
}

const authenticate = async prefs => {
  const questions = [
    {
      name: 'username',
      type: 'input',
      message: 'Enter your Eyejack Studio username or e-mail address:',
      validate: value => {
        if (value.length) {
          return true
        } else {
          return 'Please enter your username or e-mail address'
        }
      }
    },
    {
      name: 'password',
      type: 'password',
      message: 'Enter your password:',
      validate: value => {
        if (value.length) {
          return true
        } else {
          return 'Please enter your password'
        }
      }
    }
  ]
  let status = new Spinner(chalk.yellow('Authenticating...'))

  const answers = await inquirer.prompt(questions)
  try {
    status.start()
    const params = {
      username: answers.username,
      password: answers.password
    }

    const { post } = useApi('/auth/login', false, prefs)
    const res = await post(params)
    status.stop()
    return {
      tokens: res.auth_tokens,
      user: res.user
    }
  } catch (err) {
    console.log(chalk.red(err))
    process.exit(0)
  }
}

const login = async () => {
  const prefs = new Preferences(CLI_ID)
  if (prefs.auth && prefs.auth.tokens) {
    console.log(chalk.green('Already authenticated'))
    return
  }
  try {
    const tokens = await authenticate(prefs)
    prefs.auth = tokens
  } catch (err) {
    console.log(chalk.red(err))
  }
}

const logout = () => {
  const prefs = new Preferences(CLI_ID)
  prefs.auth = undefined
}

const createRemoteProject = async (name, createdBy, workspaceId, prefs) => {
  try {
    const params = {
      name,
      createdBy,
      workspaceId,
      projectId: kebabCase(name)
    }
    //const result = await api.post('/projects', params)
    const { post } = useApi('/projects', true, prefs)
    const result = await post(params)
    // associate user with project
    const { post: collabPost } = useApi(
      '/projects/addCollaborator',
      true,
      prefs
    )
    const collabRes = await collabPost({
      username: createdBy,
      projectId: result.projectId
    })

    return result
  } catch (err) {
    console.log(chalk.red(`Error creating new project: ${err}`))
  }
}

// const newPreviewLongPoll = async previewUrl => {
//   const result = await axios.get(previewUrl)
//   if (result.status === 404) {
//     setTimeout(() => {
//       newPreviewLongPoll(previewUrl)
//     }, 4000)
//   } else {
//     await open(previewUrl)
//   }
// }

const upload = async () => {
  const prefs = new Preferences(CLI_ID)
  let status = new Spinner(chalk.yellow('Checking authentication...'))
  status.start()
  if (!prefs.auth) {
    status.stop()
    try {
      const tokens = await authenticate()
      prefs.auth = tokens
    } catch (err) {
      console.log(chalk.red(err))
    }
  }
  status.stop()
  status = new Spinner(chalk.yellow('Uploading project to EyeJack Studio...'))
  status.start()
  // build app

  const execPromise = util.promisify(exec)

  try {
    // wait for exec to complete
    const { stdout, stderr } = await execPromise('npm run build')
    console.log(stdout)
  } catch (error) {
    console.log(error)
  }

  if (await fs.existsSync('./artifact.zip')) {
    await fs.remove('./artifact.zip')
  }
  await compressFolder(`${process.cwd()}/dist`, `${process.cwd()}/artifact.zip`)
  const projectId = await getProjectId()
  // initialise project state if it hasn't been already
  await initialiseProject(projectId)
  const projectConfig = await fs.readJsonSync('.ejx.json')

  if (projectConfig.remoteProjectId === '') {
    if (projectConfig.workspaceId === '') {
      const { post } = useApi('/workspaces/list', true, prefs)
      const result = await post({
        username: prefs.auth.user.username
      })
      prefs.workspaceId = result[0].workspaceId
      projectConfig.workspaceId = result[0].workspaceId
    }
    try {
      const { post } = useApi('/projects/list', true, prefs)
      const projResp = await post({
        username: prefs.auth.user.username,
        workspaceId: prefs.workspaceId
      })

      prefs.workspaceProjects = projResp
    } catch (err) {
      console.log(err)
    }
    if (
      prefs.workspaceProjects &&
      !prefs.workspaceProjects.find(obj => obj.projectId === projectId)
    ) {
      status.stop()
      const remoteProjectQuestion = {
        type: 'list',
        name: 'remoteProject',
        message: 'Choose a remote projects to upload to:',
        choices: [
          new inquirer.Separator(),
          'Create new remote project',
          new inquirer.Separator(),
          ...prefs.workspaceProjects.map(proj => proj.name)
        ],
        default: 'Create new remote project'
      }

      let newRemoteProjectFlag = false
      const questions = []
      if (prefs.workspaceProjects.length > 0) {
        questions.push(remoteProjectQuestion)
        questions.push({
          type: 'input',
          name: 'remoteProjectName',
          message: 'Enter a name for the remote project',
          default: '',
          when: answers => {
            return answers.remoteProject == 'Create new remote project'
          }
        })
      } else {
        questions.push({
          type: 'input',
          name: 'remoteProjectName',
          message: 'Enter a name for the remote project',
          default: ''
        })
        newRemoteProjectFlag = true
      }
      await inquirer.prompt(questions).then(async answers => {
        if (
          answers.remoteProject === 'Create new remote project' ||
          newRemoteProjectFlag
        ) {
          status.start()
          const res = await createRemoteProject(
            answers.remoteProjectName,
            prefs.auth.user.username,
            prefs.workspaceId,
            prefs
          )
          projectConfig.remoteProjectId = res.projectId
        } else {
          prefs.workspaceProjects.forEach(proj => {
            if (proj.name === answers.remoteProject) {
              projectConfig.remoteProjectId = proj.projectId
            }
          })
        }
      })
    }
  }
  try {
    const params = {
      workspaceId: prefs.workspaceId,
      projectId: projectConfig.remoteProjectId,
      extention: 'zip'
    }
    const { post } = useApi('/project/createUploadURL', true, prefs)
    const result = await post(params)
    const path = `${process.cwd()}/artifact.zip`
    const file = await fs.readFile(path)
    await axios
      .put(result.preSignedUrl, file, {
        headers: { 'Content-Type': 'application/zip' }
      })
      .then(async res => {
        await fs.remove('./artifact.zip')

        const previewUrl = `${EXTERNAL_URL}/${prefs.workspaceId}/${projectConfig.remoteProjectId}/`

        //await newPreviewLongPoll(previewUrl)
        await open(previewUrl)
      })
      .catch(error => {
        console.error('error sending to s3:', error)
      })
  } catch (err) {
    console.log(chalk.red(`Error creating upload url: ${err}`))
  }
  await fs.writeFileSync('.ejx.json', JSON.stringify(projectConfig))
  status.stop()
}

const ejx = async command => {
  switch (command) {
    case 'create':
      createNewProject(err => {
        if (err) {
          console.log('An error has occured')
        }
      })
      break
    case 'login':
      login(err => {
        if (err) {
          console.log('An error has occured')
        }
      })
      break
    case 'logout':
      logout()
      break
    case 'publish':
      await upload()
      break
    default:
      console.log('please enter a command, login, logout, create or publish')
      break
  }
}

const command = process.argv[2]

ejx(command)
