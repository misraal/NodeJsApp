import { Vector3 as h, BufferGeometry as ue, Float32BufferAttribute as F, Raycaster as be, Vector2 as g, MathUtils as te, Mesh as y, BackSide as O, FrontSide as L, Color as k, RawShaderMaterial as K, Vector4 as xe, DoubleSide as $, sRGBEncoding as N, RepeatWrapping as _, NearestFilter as Ce, LinearEncoding as he, TextureLoader as de, BoxGeometry as Me, MeshBasicMaterial as z, Object3D as E, PlaneGeometry as V, OrthographicCamera as me, ShaderMaterial as B, UniformsUtils as j, WebGLRenderTarget as S, Clock as fe, AdditiveBlending as we, ColorManagement as Te, Plane as ye, WebGLRenderer as Fe, NoToneMapping as ke, PerspectiveCamera as Be, Scene as G, ClampToEdgeWrapping as ie, LinearFilter as re, RGBAFormat as Pe, UnsignedByteType as Ie, Texture as De, Matrix4 as Ee, Box2 as ne, Matrix3 as Se } from "three";
import { OrbitControls as Re } from "three/examples/jsm/controls/OrbitControls.js";
import { RGBELoader as Ne } from "three/examples/jsm/loaders/RGBELoader.js";
import { RoundedBoxGeometry as ze } from "three/examples/jsm/geometries/RoundedBoxGeometry.js";
const P = /* @__PURE__ */ Object.create(null);
P.disposeMaterial = (a) => {
  Object.keys(a).forEach((e) => {
    a[e] && a[e] !== null && typeof a[e].dispose == "function" && a[e].dispose();
  }), a.dispose();
};
P.disposeRecursive = (a) => {
  for (; a.children.length > 0; )
    Ue(a.children[0]), a.remove(a.children[0]);
  a.geometry && a.geometry.dispose(), a.material && (Array.isArray(a.material) ? a.material.forEach(P.disposeMaterial) : P.disposeMaterial(a.material));
};
const Ue = P.disposeRecursive, x = /* @__PURE__ */ Object.create(null);
x.getFaceNormals = () => {
  const a = [];
  return a.push(new h(0, 0, 1)), a.push(new h(1, 0, 0)), a.push(new h(0, 0, -1)), a.push(new h(-1, 0, 0)), a.push(new h(0, 1, 0)), a.push(new h(0, -1, 0)), a;
};
const _e = x.getFaceNormals;
x.getFaceCentres = () => {
  const a = [];
  return a.push(new h(0, 0, 0.5)), a.push(new h(0.5, 0, 0)), a.push(new h(0, 0, -0.5)), a.push(new h(-0.5, 0, 0)), a.push(new h(0, 0.5, 0)), a.push(new h(0, -0.5, 0)), a;
};
const Ae = x.getFaceCentres;
x.getFaceColorMasks = () => {
  const a = [];
  return a.push(new h(1, 0, 0)), a.push(new h(0, 1, 0)), a.push(new h(0, 0, 1)), a.push(new h(1, 0, 1)), a.push(new h(1, 1, 0)), a.push(new h(0, 1, 1)), a;
};
x.getFaceColorMasks;
x.getFaceDescriptors = () => {
  const a = [];
  return a.push("front"), a.push("right"), a.push("back"), a.push("left"), a.push("top"), a.push("bottom"), a;
};
x.getFaceDescriptors;
x.initCubeGeometry = () => {
  const a = new ue();
  a.name = "EJCubeGeometry";
  const e = [];
  e.push(-1, -1, 1), e.push(1, -1, 1), e.push(-1, 1, 1), e.push(1, 1, 1), e.push(-1, -1, -1), e.push(1, -1, -1), e.push(-1, 1, -1), e.push(1, 1, -1);
  for (let d = 0; d < e.length; d++)
    e[d] *= 0.5;
  const t = [];
  t.push(1, 0, 1, 0.5), t.push(1, 0, 1, 0.5), t.push(1, 0, 1, 0.5), t.push(1, 0, 1, 0.5), t.push(1, 0, 1, 0.5), t.push(1, 0, 1, 0.5), t.push(1, 0, 1, 0.5), t.push(1, 0, 1, 0.5);
  const i = [];
  i.push(0, 3, 2), i.push(0, 1, 3), i.push(1, 7, 3), i.push(1, 5, 7), i.push(5, 6, 7), i.push(5, 4, 6), i.push(4, 2, 6), i.push(4, 0, 2), i.push(2, 7, 6), i.push(2, 3, 7), i.push(4, 1, 0), i.push(4, 5, 1);
  const n = [], r = [];
  for (let d = 0; d < i.length; d++) {
    const m = i[d], f = m * 3;
    n.push(e[f + 0]), n.push(e[f + 1]), n.push(e[f + 2]);
    const o = m * 4;
    r.push(t[o + 0]), r.push(t[o + 1]), r.push(t[o + 2]), r.push(t[o + 3]);
  }
  const s = [];
  for (let d = 0; d < 6; d++)
    s.push(0, 0), s.push(1, 1), s.push(0, 1), s.push(0, 0), s.push(1, 0), s.push(1, 1);
  const l = [], c = _e();
  for (let d = 0; d < c.length; d++) {
    const m = c[d];
    for (let f = 0; f < 6; f++)
      l.push(m.x, m.y, m.z);
  }
  const w = [], C = Ae();
  for (let d = 0; d < C.length; d++) {
    const m = C[d];
    for (let f = 0; f < 6; f++)
      w.push(m.x, m.y, m.z);
  }
  const p = [];
  for (let d = 0; d < 6; d++)
    for (let m = 0; m < 6; m++)
      p.push(d);
  return a.setAttribute("position", new F(n, 3)), a.setAttribute("centre", new F(w, 3)), a.setAttribute("normal", new F(l, 3)), a.setAttribute("color", new F(r, 4)), a.setAttribute("uv", new F(s, 2)), a.setAttribute("face", new F(p, 1)), a;
};
x.initCubeGeometry;
const J = "None", A = "Plain", q = "Glass", Q = "Glass3";
class Y {
  /**
   * @param {Object3D} container
   * @param {any} gui
   */
  constructor(e, t) {
    this.style = J, this.container = e, this.cubeBack = null, this.cubeFront = null, this.cubeToCameraDist = 100, this.cubeToCameraDistNorm = 1, this.cubeToCameraThreshold = 0.05, this.raycaster = new be(), this.canGoInsideCube = !1, this.gui = t, this.gui && (this.guiFolder = this.gui.addFolder("Cube Settings"));
  }
  updateProps(e, t, i) {
    this.canGoInsideCube = i;
  }
  updateMasterOpacity(e) {
  }
  /**
   * @param {Camera} camera
   */
  update(e) {
    this.cubeToCameraDist = 100, this.raycaster.setFromCamera(new g(0, 0), e);
    const t = this.raycaster.intersectObject(this.cubeFront);
    if (t.length > 0) {
      const n = t[0];
      this.cubeToCameraDist = n.distance;
    }
    this.raycaster.ray.direction.multiply(new h(-1, -1, -1));
    const i = this.raycaster.intersectObject(this.cubeBack);
    if (i.length > 0) {
      const n = i[0];
      this.cubeToCameraDist = -n.distance;
    }
    this.cubeToCameraDistNorm = te.mapLinear(this.cubeToCameraDist, -this.cubeToCameraThreshold, this.cubeToCameraThreshold, -1, 1), this.cubeToCameraDistNorm = te.clamp(this.cubeToCameraDistNorm, -1, 1);
  }
  dispose() {
    this.container && P.disposeRecursive(this.container), this.guiFolder && (this.guiFolder.destroy(), this.guiFolder = null);
  }
}
function se() {
  return new K({
    uniforms: {
      backFace: { value: 1 },
      borderOn: { value: 1 },
      borderColor: { value: new xe(1, 1, 1, 0.25) },
      borderWidth: { value: 25e-4 },
      borderFeather: { value: 0.5 },
      textureOn: { value: 1 },
      texture: { type: "t", value: null },
      resolution: { value: new g(0, 0) },
      masterOpacity: { value: 1 }
    },
    vertexShader: `
      precision highp float;
      precision highp int;

      uniform mat4 modelMatrix;
      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;

      attribute vec3 position;
      attribute vec4 color;
      attribute vec2 uv;
      
      varying vec2 vUv;
      
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    `,
    // grid shader.
    // http://madebyevan.com/shaders/grid/
    //
    fragmentShader: `
      precision highp float;
      precision highp int;
      
      uniform int backFace;
      uniform int borderOn;
      uniform vec4 borderColor;
      uniform float borderWidth;
      uniform float borderFeather;
      uniform int textureOn;
      uniform sampler2D texture;
      uniform vec2 resolution;
      uniform float masterOpacity;
      
      varying vec2 vUv;

      vec4 alphaBlend( vec4 src, vec4 dst ) {
        float final_alpha = src.a + dst.a * (1.0 - src.a);
        if( final_alpha == 0.0 ) {
          return vec4( 0.0, 0.0, 0.0, 0.0 );
        }
        return vec4( (src.rgb * src.a + dst.rgb * dst.a * (1.0 - src.a)) / final_alpha, final_alpha);
      }

      float border(vec2 uv, float strokeWidth, float feather) {
        vec2 borderBottomLeft = smoothstep(vec2(strokeWidth * feather), vec2(strokeWidth), uv);
        vec2 borderTopRight = smoothstep(vec2(strokeWidth * feather), vec2(strokeWidth), 1.0 - uv);
        return 1.0 - borderBottomLeft.x * borderBottomLeft.y * borderTopRight.x * borderTopRight.y;
      }

      vec4 LinearTosRGB( vec4 value ) {
        return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
      }      
      
      void main()  {
        vec4 colorTex = vec4(0.0, 0.0, 0.0, 0.0);
        vec4 colorBorder = vec4(0.0, 0.0, 0.0, 0.0);
        
        if(textureOn == 1) {
          vec2 st = gl_FragCoord.xy / resolution;
          colorTex = texture2D(texture, st);
        }

        if(borderOn == 1 && borderWidth > 0.0 && borderColor.a > 0.0) {
          float line = border(vUv, borderWidth, 1.0 - borderFeather);
          colorBorder = vec4(borderColor.xyz, borderColor.a * line);
        }

        vec4 colorFinal = vec4(0.0, 0.0, 0.0, 0.0);
        if( backFace == 0 ) {
          colorFinal = alphaBlend(colorBorder, colorTex); // border first, then blend content on top.
        } else {
          colorFinal = alphaBlend(colorTex, colorBorder); // content first, then blend border on top.
        }

        colorFinal = LinearTosRGB( colorFinal );
        colorFinal.a *= masterOpacity;

        gl_FragColor = colorFinal;
      }      
    `,
    side: $,
    transparent: !0
  });
}
class We extends Y {
  constructor(e, t) {
    super(e, t), this.style = A, this.geometry = x.initCubeGeometry(), this.materialBack = se(), this.materialFront = se(), this.cubeBack = new y(this.geometry, this.materialBack), this.cubeBack.name = "cubeBack", this.materialBack.side = O, this.materialBack.uniforms.backFace.value = 1, this.materialBack.uniforms.textureOn.value = 1, this.materialBack.uniformsNeedUpdate = !0, this.cubeFront = new y(this.geometry, this.materialFront), this.cubeFront.name = "cubeFront", this.materialFront.side = L, this.materialFront.uniforms.backFace.value = 0, this.materialFront.uniforms.textureOn.value = 0, this.materialFront.uniformsNeedUpdate = !0, this.container.add(this.cubeBack), this.container.add(this.cubeFront), this.config = {
      masterOpacity: 1,
      borderOn: !0,
      borderWidth: 25e-4,
      borderFeather: 0.5,
      borderColor: new k(16777215),
      borderAlpha: 0.25
    }, this.guiFolder && (this.guiFolder.add(this.config, "masterOpacity", 0, 1).name("Master Opacity").onChange((i) => {
      this.updateMasterOpacity(i);
    }), this.guiFolder.add(this.config, "borderOn").name("Border On").onChange((i) => {
      this.materialBack.uniforms.borderOn.value = i ? 1 : 0, this.materialBack.uniformsNeedUpdate = !0, this.materialFront.uniforms.borderOn.value = i ? 1 : 0, this.materialFront.uniformsNeedUpdate = !0;
    }), this.guiFolder.add(this.config, "borderWidth", 0, 0.1).name("Border Width").onChange((i) => {
      this.materialBack.uniforms.borderWidth.value = i, this.materialBack.uniformsNeedUpdate = !0, this.materialFront.uniforms.borderWidth.value = i, this.materialFront.uniformsNeedUpdate = !0;
    }), this.guiFolder.add(this.config, "borderFeather", 0, 1).name("Border Feather").onChange((i) => {
      this.materialBack.uniforms.borderFeather.value = i, this.materialBack.uniformsNeedUpdate = !0, this.materialFront.uniforms.borderFeather.value = i, this.materialFront.uniformsNeedUpdate = !0;
    }), this.guiFolder.addColor(this.config, "borderColor").name("Border Color").onChange((i) => {
      this.materialBack.uniforms.borderColor.value.x = i.r, this.materialBack.uniforms.borderColor.value.y = i.g, this.materialBack.uniforms.borderColor.value.z = i.b, this.materialBack.uniformsNeedUpdate = !0, this.materialFront.uniforms.borderColor.value.x = i.r, this.materialFront.uniforms.borderColor.value.y = i.g, this.materialFront.uniforms.borderColor.value.z = i.b, this.materialFront.uniformsNeedUpdate = !0;
    }), this.guiFolder.add(this.config, "borderAlpha", 0, 1).name("Border Alpha").onChange((i) => {
      this.materialBack.uniforms.borderColor.value.w = i, this.materialBack.uniformsNeedUpdate = !0, this.materialFront.uniforms.borderColor.value.w = i, this.materialFront.uniformsNeedUpdate = !0;
    }));
  }
  update(e) {
    super.update(e);
  }
  updateProps(e, t, i) {
    super.updateProps(e, t, i), this.materialBack.uniforms.resolution.value = t, this.materialBack.uniforms.texture.value = e, this.materialBack.uniformsNeedUpdate = !0, this.materialFront.uniforms.resolution.value = t, this.materialFront.uniforms.texture.value = e, this.materialFront.uniformsNeedUpdate = !0;
  }
  updateMasterOpacity(e) {
    this.materialBack.uniforms.masterOpacity.value = e, this.materialBack.uniformsNeedUpdate = !0, this.materialFront.uniforms.masterOpacity.value = e, this.materialFront.uniformsNeedUpdate = !0;
  }
}
function ae() {
  return new K({
    name: "EJCube1Material",
    uniforms: {
      mode: { value: 0 },
      time: { value: 1 },
      resolution: { value: new g(0, 0) },
      texture: { type: "t", value: null },
      tintAlpha: { value: 0.4 },
      cubeToCameraDistNorm: { value: 1 },
      canGoInsideCube: { value: !1 }
    },
    vertexShader: `
      precision highp float;
      precision highp int;

      uniform mat4 modelViewMatrix; // optional
      uniform mat4 projectionMatrix; // optional

      attribute vec3 position;
      attribute vec3 centre;
      attribute vec3 normal;
      attribute vec4 color;
      attribute vec2 uv;

      varying vec3 vPosition;
      varying vec4 vPositionWorld;
      varying vec3 vCentre;
      varying vec4 vCentreWorld;
      varying vec3 vNormal;
      varying vec4 vColor;
      varying vec2 vUv;

      void main() {

        vPosition = position;
        vPositionWorld = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        vCentre = centre;
        vCentreWorld = projectionMatrix * modelViewMatrix * vec4( centre, 1.0 );
        vNormal = normal;
        vColor = color;
        vUv = uv;

        gl_Position = vPositionWorld;
      }
    `,
    fragmentShader: `
      precision highp float;
      precision highp int;

      uniform int mode;
      uniform float time;
      uniform vec2 resolution;
      uniform sampler2D texture;
      uniform float tintAlpha;
      uniform float cubeToCameraDistNorm;
      uniform bool canGoInsideCube;

      varying vec3 vPosition;
      varying vec4 vPositionWorld;
      varying vec3 vCentre;
      varying vec4 vCentreWorld;
      varying vec3 vNormal;
      varying vec4 vColor;
      varying vec2 vUv;

      const float PI2 = 6.283185307179586;

      float map( float value, float inputMin, float inputMax, float outputMin, float outputMax ) {
        if( abs(inputMin - inputMax) < 0.00001 ) {
          return outputMin;
        } else {
          float outVal = ((value - inputMin) / (inputMax - inputMin) * (outputMax - outputMin) + outputMin);
          if(outputMax < outputMin){
            if( outVal < outputMax )outVal = outputMax;
            else if( outVal > outputMin )outVal = outputMin;
          } else {
            if( outVal > outputMax )outVal = outputMax;
            else if( outVal < outputMin )outVal = outputMin;
          }
          return outVal;
        }
      }

      vec4 alphaBlend( vec4 src, vec4 dst ) {
        float final_alpha = src.a + dst.a * (1.0 - src.a);
        if( final_alpha == 0.0 ) {
          return vec4( 0.0, 0.0, 0.0, 0.0 );
        }
        return vec4( (src.rgb * src.a + dst.rgb * dst.a * (1.0 - src.a)) / final_alpha, final_alpha);
      }

      float borders(vec2 uv, float strokeWidth) {
        vec2 borderBottomLeft = smoothstep(vec2(0.0), vec2(strokeWidth), uv);
        vec2 borderTopRight = smoothstep(vec2(0.0), vec2(strokeWidth), 1.0 - uv);
        return 1.0 - borderBottomLeft.x * borderBottomLeft.y * borderTopRight.x * borderTopRight.y;
      }

      vec4 warp( vec2 st ) {
        vec2 toCenter = vCentreWorld.xy - vPositionWorld.xy;
        float direction = (atan(toCenter.y, toCenter.x) / PI2) + 0.5;
        float length = borders(vUv, 0.028) + borders(vUv, 0.06) * 0.3;
        if( false ) { // debug.
          return vec4(direction, length, 0.0, 1.0);
        }

        vec2 dir = vec2(cos(direction * PI2), sin(direction * PI2));

        vec2 stWarp = st;
        stWarp.x += (length * 0.07) * dir.x;
        stWarp.y += (length * 0.07) * dir.y;

        return texture2D(texture, stWarp);
      }

      void main()  {

        vec2 st = gl_FragCoord.xy / resolution;
        vec4 color = vec4( 0.0, 0.0, 0.0, 0.0 );

        vec4 colorBorder = vec4( borders(vUv, 0.02) );
        if( colorBorder.a > 0.0 ) {
          colorBorder.rgb /= colorBorder.a; // premultiply alpha fix for dark shadows.
        }

        float colorTexAlphaMin = 0.5;
        float frostAlphaMax = 0.6;

        if( mode == 0 ) { // cube interior / back facing.

          vec4 colorTint = vec4( 0.0, 0.0, 0.0, tintAlpha );
          vec4 colorBorderFaded = vec4( colorBorder.rgb, colorBorder.a * 0.6 );
          
          color = alphaBlend( colorBorderFaded, colorTint );

          if( cubeToCameraDistNorm < 0.0 && canGoInsideCube ) { // below 0.0, meams we're inside the cube.
            
            vec4 colorTex = texture2D(texture, st);
            float colorTexAlpha = map( cubeToCameraDistNorm, 0.0, -0.5, colorTexAlphaMin, 1.0 );
            colorTex.a *= colorTexAlpha;

            float frostAlpha = map( cubeToCameraDistNorm, 0.0, -1.0, frostAlphaMax, 0.0 );
            vec4 frostCol = vec4(1.0, 1.0, 1.0, frostAlpha );

            color = alphaBlend( colorTex, color );
            color = alphaBlend( frostCol, color );
          }

        } else { // cube exterior / front facing.

          if( cubeToCameraDistNorm < 0.0 ) {
            discard; // below 0.0, meams we're inside the cube.
          }

          vec4 colorTex = warp( st );
          float colorTexAlpha = map( cubeToCameraDistNorm, 1.0, 0.5, 1.0, colorTexAlphaMin );
          colorTex.a *= colorTexAlpha;

          float frostAlpha = map( cubeToCameraDistNorm, 1.0, 0.0, 0.0, frostAlphaMax );
          vec4 frostCol = vec4(1.0, 1.0, 1.0, frostAlpha );

          color = colorTex;
          color = alphaBlend( frostCol, color );
          color = alphaBlend( colorBorder, color );
        }

        gl_FragColor = color;
      }
    `,
    side: $,
    transparent: !0
  });
}
class Oe extends Y {
  constructor(e, t) {
    super(e, t), this.style = q, this.geometry = x.initCubeGeometry(), this.materialBack = ae(), this.materialFront = ae(), this.cubeBack = new y(this.geometry, this.materialBack), this.cubeBack.name = "cubeBack", this.cubeBack.material.side = O, this.cubeBack.material.uniforms.mode.value = 0, this.cubeBack.material.uniformsNeedUpdate = !0, this.cubeFront = new y(this.geometry, this.materialFront), this.cubeFront.name = "cubeFront", this.cubeFront.material.side = L, this.cubeFront.material.uniforms.mode.value = 1, this.cubeFront.material.uniformsNeedUpdate = !0, this.container.add(this.cubeBack), this.container.add(this.cubeFront), this.guiFolder && (this.guiFolder.add(this.materialBack.uniforms.tintAlpha, "value", 0, 1).name("Tint Alpha").onChange((i) => {
      this.materialBack.uniforms.tintAlpha.value = i, this.materialBack.uniformsNeedUpdate = !0;
    }), this.guiFolder.add(this, "cubeToCameraThreshold", 0, 1).name("Cube Threshold").onChange((i) => {
      this.cubeToCameraThreshold = i;
    }));
  }
  update(e) {
    super.update(e), this.materialBack.uniforms.cubeToCameraDistNorm.value = this.cubeToCameraDistNorm, this.materialBack.uniformsNeedUpdate = !0, this.materialFront.uniforms.cubeToCameraDistNorm.value = this.cubeToCameraDistNorm, this.materialFront.uniformsNeedUpdate = !0;
  }
  updateProps(e, t, i) {
    super.updateProps(e, t, i), this.materialBack.uniforms.resolution.value = t, this.materialBack.uniforms.texture.value = e, this.materialBack.uniforms.canGoInsideCube.value = i, this.materialBack.uniformsNeedUpdate = !0, this.materialFront.uniforms.resolution.value = t, this.materialFront.uniforms.texture.value = e, this.materialFront.uniforms.canGoInsideCube.value = i, this.materialFront.uniformsNeedUpdate = !0;
  }
  dispose() {
    super.dispose();
  }
}
const Le = `#version 300 es
//3.00 we need for normal map calc

precision highp float;
precision highp int;

//built in
//https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram
uniform mat4 modelViewMatrix; 
uniform mat4 projectionMatrix; 
uniform vec3 cameraPosition;  
uniform mat4 viewMatrix;
uniform mat4 modelMatrix;


in vec3 position;
in vec3 centre;
in vec3 normal;
in vec3 tangent;
in vec4 color;
in vec2 uv;


out vec3 vPosWorld; //correct world space 
out vec3 vNormalWorld;
// out vec3 vTangentWorld;
// out vec3 vBitangentWorld;
out vec3 vViewDir;
out vec3 vViewPosition;
// out vec4 vColor;
out vec2 vUv;

//old
out vec3 vPosition;
out vec4 vPositionWorld;
out vec3 vCentre;
out vec4 vCentreWorld;
out vec3 vNormal;


//from THREEjs examples
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
  return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}

void main() {

  vPosWorld =  ( modelMatrix * vec4( position, 1. ) ).xyz;
  vNormalWorld = inverseTransformDirection( normal, modelMatrix );
  vViewDir = normalize(vPosWorld - cameraPosition); //?

  /*
  vTangentWorld = normalize( (vec4( tangent, 0.0 ) * modelMatrix ).xyz );
  vBitangentWorld = normalize( cross( vNormalWorld, vTangentWorld ) );
  */

  //these we need to normal map calc
  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  vViewPosition = - mvPosition.xyz;

  vUv = uv;

  //old vals
  //TODO DEPRECATE
  vPosition = position;
  vPositionWorld = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  vCentre = centre;
  vCentreWorld = projectionMatrix * modelViewMatrix * vec4( centre, 1.0 );
  vNormal = normal;
  // vColor = color;

  gl_Position = vPositionWorld;
}`, Ve = `#version 300 es

precision highp float;
precision highp int;

#define PI 3.14159
#define PI2 6.283185307179586

//built in 
//https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram
uniform vec3 cameraPosition;  
uniform mat4 viewMatrix;
uniform mat4 modelMatrix;
uniform mat4 projectionMatrix;


//from vert
in vec3 vPosWorld;
in vec3 vNormalWorld;
in vec3 vViewDir;
in vec3 vViewPosition;
in vec2 vUv; //surface uvs
// in vec4 vColor;
// in vec3 vTangentWorld;
// in vec3 vBitangentWorld;

//old
in vec3 vPosition;
in vec4 vPositionWorld;
in vec3 vCentre;
in vec4 vCentreWorld;
in vec3 vNormal;

out vec4 fragColor;



uniform int mode;  //rename to faceDir 
uniform float time;
uniform vec2 resolution;
uniform sampler2D texBack; //todo rename to transmissionSamplerMap or back texture 
uniform float cubeToCameraDistNorm;
uniform bool canGoInsideCube;

uniform float tintAlpha;
uniform vec3 tintColor; //rename to tintColor
// uniform float camFOV;

uniform sampler2D texHDRI; //equirectangular HDRI
uniform float texEnvExposure;

const float normalScale = .02;
uniform sampler2D texNormal; 


/*
float map( float value, float inputMin, float inputMax, float outputMin, float outputMax ) {
  if( abs(inputMin - inputMax) < .00001 ) {
    return outputMin;
  } else {
    float outVal = ((value - inputMin) / (inputMax - inputMin) * (outputMax - outputMin) + outputMin);
    if(outputMax < outputMin){
      if( outVal < outputMax )outVal = outputMax;
      else if( outVal > outputMin )outVal = outputMin;
    } else {
      if( outVal > outputMax )outVal = outputMax;
      else if( outVal < outputMin )outVal = outputMin;
    }
    return outVal;
  }
}

vec4 alphaBlend( vec4 src, vec4 dst ) {
  float final_alpha = src.a + dst.a * (1.0 - src.a);
  if(final_alpha == .0) {
    return vec4(.0,.0,.0,.0);
  }
  return vec4( (src.rgb * src.a + dst.rgb * dst.a * (1.0 - src.a)) / final_alpha, final_alpha);
}


float borders(vec2 uv, float strokeWidth) {
  vec2 borderBottomLeft = smoothstep(vec2(0.0), vec2(strokeWidth), uv);
  vec2 borderTopRight = smoothstep(vec2(0.0), vec2(strokeWidth), 1.0 - uv);
  return 1.0 - borderBottomLeft.x * borderBottomLeft.y * borderTopRight.x * borderTopRight.y;
}

vec4 warp( vec2 st ) {
  vec2 toCenter = vCentreWorld.xy - vPositionWorld.xy;
  float direction = (atan(toCenter.y, toCenter.x) / PI2) + 0.5;
  float length = borders(vUv, 0.028) + borders(vUv, 0.06) * 0.3;
  if( false ) { // debug.
    return vec4(direction, length, 0.0, 1.0);
  }

  vec2 dir = vec2(cos(direction * PI2), sin(direction * PI2));

  vec2 stWarp = st;
  stWarp.x += (length * 0.07) * dir.x;
  stWarp.y += (length * 0.07) * dir.y;

  return texture(texBack, stWarp);
}
*/
/*
// with pre-calc tangents
vec3 getDetailNormal2(vec3 n){ 

  float normalScale = 0.02;
  vec3 mapN = texture(texNormal, vUv ).xyz * 2. - 1.;
  mapN.xy *= normalScale;


  // #ifdef FLIP_SIDED
  //   transformedTangent = - transformedTangent;
  // #endif


  vec3 tangent = normalize( vTangentWorld );
  vec3 bitangent = normalize( vBitangentWorld );

  // #ifdef DOUBLE_SIDED
  //   tangent = tangent * faceDirection;
  //   bitangent = bitangent * faceDirection;
  // #endif
  // #if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )

  mat3 vTBN = mat3( vTangentWorld, vBitangentWorld, vNormalWorld );
  vec3 nDetailed = normalize( vTBN * mapN );



  // float faceDirection = gl_FrontFacing ? 1. : - 1.;
  // vec3 nDetailed = applyNormalMap( n, mapN, faceDirection ); 
  return nDetailed;

}
*/



//https://stackoverflow.com/questions/56625730/does-blending-work-with-the-glsl-mix-function
vec4 blend(vec4 src, vec4 dst, float alpha){ return src*alpha + dst*(1.-alpha); }

// vec3 bms(vec3 a, vec3 b){ return 1.- (1.-a)*(1.-b); }
// float bms(float a, float b){ return 1.- (1.-a)*(1.-b); }


//Equirectangular HDRI
//https://www.shadertoy.com/view/4lK3DK
vec3 getHDRI(vec3 rd){
  vec2 uv = vec2(atan(rd.z, rd.x) + PI, acos(-rd.y)) / vec2(2. * PI, PI); //TODO PI2
  vec3 col = texture(texHDRI, uv).rgb;
  //TODO: on THREEjs side
  col = pow(col, vec3(2.2)); //sRGB -> Linear, 
  col *= texEnvExposure;
  return col;
}

//Note: it will be faster with precomputed tangents. bi tangents cud be calculated from t x n
//from normalmap_pars_fragment.glsl.js
// Normal Mapping Without Precomputed Tangents
// http://www.thetenthplanet.de/archives/1180
vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {

  vec3 q0 = dFdx( eye_pos.xyz );
  vec3 q1 = dFdy( eye_pos.xyz );
  vec2 st0 = dFdx( vUv.st );
  vec2 st1 = dFdy( vUv.st );

  vec3 N = surf_norm; // normalized

  vec3 q1perp = cross( q1, N );
  vec3 q0perp = cross( N, q0 );

  vec3 T = q1perp * st0.x + q0perp * st1.x;
  vec3 B = q1perp * st0.y + q0perp * st1.y;

  float det = max( dot( T, T ), dot( B, B ) );
  float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );

  return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );

}

vec3 getDetailNormal(vec3 n){ 

  // float normalScale = 0.02;
  vec3 mapN = texture(texNormal, vUv).xyz * 2. - 1.;
  mapN.xy *= normalScale;

  //TODO check with main normal - coz we flip it also
  float faceDirection = gl_FrontFacing ? 1. : - 1.;

  vec3 normal = perturbNormal2Arb( - vViewPosition, n, mapN, faceDirection );
  return normal;
}


//back texture refration
//from transmission_pars_fragment.glsl.js
vec4 transmission(vec3 n){

  vec3 pos = vPosWorld;
  vec3 v = -vViewDir;
  float ior = 2.;  //we use different ior for refration coz it looks better
  float thickness = .05;

  //face dir==back face
  // if(mode==0) ior = 1./ior; //glass to air

  // Direction of refracted light.
  vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );

  // Compute rotation-independant scaling of the model matrix.
  vec3 modelScale;
  modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
  modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
  modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );

  // The thickness is specified in local space.
  vec3 transmissionRay =  normalize( refractionVector ) * thickness * modelScale;

  vec3 refractedRayExit = pos + transmissionRay;

  // Project refracted vector on the framebuffer, 
  // while mapping to normalized device coordinates.
  vec4 ndcPos = projectionMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
  vec2 refractionCoords = ndcPos.xy / ndcPos.w;
  refractionCoords += 1.0;
  refractionCoords /= 2.0;

  vec4 col = texture(texBack, refractionCoords.xy).xyzw;
  return col;

}


//surface shading 

//fresnel-schlick
const float EPS = 1e-3;
float dot_c(vec3 a, vec3 b){ return max(dot(a, b), EPS); } //clamped dot with min eps val
float fre(vec3 n, vec3 rayDir, float ior){
  float f0 = pow(ior - 1., 2.) / pow(ior + 1., 2.); 
  float cosTheta = dot_c(n, -rayDir);
  float f = f0 + (1.-f0) * pow(1.-cosTheta, 5.);
  return f;
}


vec4 shadeFront(vec3 p, vec3 n, vec3 rayDir){ 
  
  vec4 col = vec4(0.,0.,0.,0.); 
  vec4 ambientCol = transmission(n); //back texture refraction

  vec3 reflectedCol = getHDRI(reflect(rayDir, n));
  
  //this one is for fresnel. we have another one for refraction. coz it looks better
  float ior = 1.2;
  float f = fre(n, rayDir, ior);

  vec4 colTint = vec4(tintColor, tintAlpha);

  col = colTint;
  col = blend(ambientCol, col, ambientCol.a );   //inner material 
  col = blend(vec4(reflectedCol,1.), col, f ); //surface material 

  // col = mix(ambientCol, vec4(reflectedCol,1.), vec4(f.x) );

  return col;
}


vec4 shadeBack(vec3 p, vec3 n, vec3 rayDir){ 

  vec4 col = vec4(0.,0.,0.,0.);
  // vec4 colTint = vec4(tintColor, tintAlpha);

  vec3 reflectedCol = getHDRI(reflect(rayDir, n));
  
  float ior = 1.2;
  float f = fre(n, rayDir,ior);

  col = blend(vec4(reflectedCol, 1.), col, f );

  return col;
}



void main()  {

  vec2 uv = gl_FragCoord.xy / resolution; //screen uvs
  // bool faceDir = gl_FrontFacing;// ? 1. : - 1.;
  vec4 col = vec4(0.,0.,0.,0.);

  /*
  vec4 colBorder = vec4( borders(vUv, 0.02) );
  if( colBorder.a > 0.0 ) {
    colBorder.rgb /= colBorder.a; // premultiply alpha fix for dark shadows.
  }

  float colTexAlphaMin = 0.5;
  float frostAlphaMax = 0.6;
  */

  //Back face, cube interior 
  if( mode == 0 ) { 

/*
    vec4 colTint = vec4( tintColor, tintAlpha );
    // vec4 colBorderFaded = vec4( colBorder.rgb, colBorder.a * 0.6 );
    
    // col = alphaBlend( colBorderFaded, colTint );
    col =  colTint ;

    // below 0.0, means we're inside the cube.
    if( cubeToCameraDistNorm < 0.0 && canGoInsideCube ) { 
      
      vec4 colTex = texture(texBack, uv); //back texture?
      float colTexAlpha = map( cubeToCameraDistNorm, 0.0, -0.5, colTexAlphaMin, 1.0 );
      colTex.a *= colTexAlpha;

      // float frostAlpha = map( cubeToCameraDistNorm, 0., -1., frostAlphaMax, 0. );
      // vec4 frostCol = vec4(1., 1., 1., frostAlpha );

      col = alphaBlend( colTex, col );
      // col = alphaBlend( frostCol, col );

    }
*/
    

    vec3 p = vPosWorld;       //pos on surface
    vec3 n = -vNormalWorld;   //normal on surface: flipped for the back 
    //TODO check normal map along with this flipped normal - but its not critical

    vec3 rayDir = normalize(vViewDir); //already normalized, rename to viewDir
    vec3 nDetailed = getDetailNormal(n); //normalized

    vec4 colSurface = shadeBack(p, nDetailed, rayDir);
    col = colSurface; 

  } 

  // Front Face, cube exterior 
  else { 

    /*
    //clip front face?
    if( cubeToCameraDistNorm < 0.0 ) {
      discard; // below 0.0, means we're inside the cube.
    }

    vec4 colTex = warp( uv );

    float colTexAlpha = map( cubeToCameraDistNorm, 1., .5, 1., colTexAlphaMin );
    colTex.a *= colTexAlpha;

    float frostAlpha = map( cubeToCameraDistNorm, 1., 0., 0., frostAlphaMax );
    vec4 frostCol = vec4(1., 1., 1., frostAlpha );

    col = colTex;
    
    col = alphaBlend( frostCol, col );
    col = alphaBlend( colBorder, col );
    */

    vec3 p = vPosWorld;       //pos on surface
    vec3 n = vNormalWorld;    //normal on surface

    
    vec3 rayDir = normalize(vViewDir); //already normalized, todo renme to viewDir
    vec3 nDetailed = getDetailNormal(n); //normalized


    vec4 colSurface = shadeFront(p, nDetailed, rayDir);
    col = colSurface;
  }

  // col.xyz = pow(col.xyz, vec3(.4545) ); //gamma coorection

  fragColor = col;
}
`;
class He {
  constructor() {
    this.texLoader = null, this.rgbeLoader = null, this.pmremGenerator = null, this.texNormal = [
      "n9.jpg",
      "n12.jpg",
      "n14.jpg",
      "n16.jpg"
      // 'n17.jpg',
    ], this.texEnv = [
      "studio016.hdr",
      "empty_warehouse_01_1k.hdr",
      // 'old_bus_depot_1k.hdr',
      "hamburg_hbf_1k.hdr"
    ], this.texRoughness = [
      "h17.jpg",
      "h9.jpg",
      "h12.jpg",
      "h14.jpg",
      "h16.jpg"
    ], this.texNormalId = 0, this.texEnvId = 0;
  }
  loadNormalMap(e, t) {
    this.texNormalId = t, this.texLoader.load("/libs/ejx/assets/normal/" + this.texNormal[t], function(i) {
      i.encoding = N, i.wrapS = _, i.wrapT = _;
      for (let n = 0; n < e.length; n++)
        e[n].uniforms.texNormal.value = i, e[n].uniformsNeedUpdate = !0;
    });
  }
  // loads env map
  loadEnvMap(e, t) {
    this.texEnvId = t, this.rgbeLoader.load("/libs/ejx/assets/env/" + this.texEnv[t], function(i) {
      i.minFilter = Ce, i.wrapS = _, i.wrapT = _, i.encoding = he;
      for (let n = 0; n < e.length; n++)
        e[n].uniforms.texHDRI.value = i, n == 0 && (e[n].uniforms.texEnvExposure.value = 1), n == 1 && (e[n].uniforms.texEnvExposure.value = 0.2), n == 2 && (e[n].uniforms.texEnvExposure.value = 0.02), e[n].uniformsNeedUpdate = !0;
    });
  }
  loadRoughnessMap(e, t) {
    this.texRoughnessId = t, this.texLoader.load("/libs/ejx/assets/rough/" + this.texRoughness[t], function(i) {
      i.encoding = N, e.roughnessMap = i, e.needsUpdate = !0;
    });
  }
}
function oe() {
  return new K({
    vertexShader: Le,
    fragmentShader: Ve,
    uniforms: {
      mode: { value: 0 },
      // TODO rename to faceDir
      time: { value: 1 },
      resolution: { value: new g(0, 0) },
      texBack: { value: null },
      tintColor: { value: new k(0) },
      tintAlpha: { value: 0.2 },
      texHDRI: { value: null },
      texEnvExposure: { value: 0.2 },
      texNormal: { value: null },
      cubeToCameraDistNorm: { value: 1 },
      canGoInsideCube: { value: !1 }
      // camFOV: {value: 50.}, //TODO set
      // cameraPos: {value: new THREE.Vector3(0)},
    },
    side: $,
    transparent: !0
  });
}
class Ge extends Y {
  constructor(e, t) {
    super(e, t), this.style = Q, this.geometry = new ze(1, 1, 1, 4, 0.02), this.materialBack = oe(), this.materialFront = oe(), this.cubeBack = new y(this.geometry, this.materialBack), this.cubeBack.name = "cubeBack", this.cubeBack.material.side = O, this.cubeBack.material.uniforms.mode.value = 0, this.cubeBack.material.uniformsNeedUpdate = !0, this.cubeFront = new y(this.geometry, this.materialFront), this.cubeFront.name = "cubeFront", this.cubeFront.material.side = L, this.cubeFront.material.uniforms.mode.value = 1, this.cubeFront.material.uniformsNeedUpdate = !0, this.container.add(this.cubeBack), this.container.add(this.cubeFront);
    let i = new He();
    i.texLoader = new de(), i.rgbeLoader = new Ne(), i.loadNormalMap([this.materialFront, this.materialBack], 1), i.loadEnvMap([this.materialFront, this.materialBack], 2), this.guiFolder && (this.guiFolder.add(i, "texNormalId", 0, i.texNormal.length - 1).step(1).name("Normal Map").onChange((n) => {
      i.loadNormalMap([this.materialFront, this.materialBack], n);
    }), this.guiFolder.add(i, "texEnvId", 0, i.texEnv.length - 1).step(1).name("Env Map").onChange((n) => {
      i.loadEnvMap([this.materialFront, this.materialBack], n);
    }), this.guiFolder.add(this.materialFront.uniforms.texEnvExposure, "value", 0, 2).name("Env Exposure").onChange((n) => {
      this.materialBack.uniforms.texEnvExposure.value = n, this.materialBack.uniformsNeedUpdate = !0, this.materialFront.uniforms.texEnvExposure.value = n, this.materialFront.uniformsNeedUpdate = !0;
    }), this.guiFolder.add(this.materialFront.uniforms.tintAlpha, "value", 0, 1).name("Tint Alpha").onChange((n) => {
      this.materialFront.uniformsNeedUpdate = !0;
    }), this.guiFolder.addColor(this.materialFront.uniforms.tintColor, "value").name("Tint Color").onChange((n) => {
      this.materialFront.uniforms.tintColor.value = n, this.materialFront.uniformsNeedUpdate = !0;
    }), this.guiFolder.add(this, "cubeToCameraThreshold", 0, 1).name("Cube Threshold").onChange((n) => {
      this.cubeToCameraThreshold = n;
    }));
  }
  update(e) {
    super.update(e), this.materialBack.uniforms.cubeToCameraDistNorm.value = this.cubeToCameraDistNorm, this.materialBack.uniformsNeedUpdate = !0, this.materialFront.uniforms.cubeToCameraDistNorm.value = this.cubeToCameraDistNorm, this.materialFront.uniformsNeedUpdate = !0;
  }
  updateProps(e, t, i) {
    super.updateProps(e, t, i), this.materialBack.uniforms.resolution.value = t, this.materialBack.uniforms.texBack.value = e, this.materialBack.uniforms.canGoInsideCube.value = i, this.materialBack.uniformsNeedUpdate = !0, this.materialFront.uniforms.resolution.value = t, this.materialFront.uniforms.texBack.value = e, this.materialFront.uniforms.canGoInsideCube.value = i, this.materialFront.uniformsNeedUpdate = !0;
  }
  dispose() {
    super.dispose();
  }
}
class je {
  constructor(e) {
    this.container = e, this.cubeBackGeometry = new Me(1, 1, 1), this.cubeBackGeometry.name = "EJCubeMask_BackGeometry", this.cubeBackMaterial = new z({
      name: "EJCubeMask_BackMaterial",
      color: 16711680,
      side: O,
      depthWrite: !1,
      depthTest: !1
    }), this.cubeBack = new y(this.cubeBackGeometry, this.cubeBackMaterial), this.cubeBack.name = "EJCubeMask_BackMesh", this.cubeBack.frustumCulled = !1, this.container.add(this.cubeBack);
    const t = x.getFaceColorMasks();
    this.cubeFront = new E(), this.cubeFrontFaces = [];
    for (let i = 0; i < 6; i++) {
      const n = t[i], r = new V(1, 1);
      r.name = `EJCubeMask_FrontGeometry_${i}`;
      const s = new z({
        color: new k(n.x, n.y, n.z),
        side: L,
        depthWrite: !1,
        depthTest: !1
      });
      r.name = `EJCubeMask_FrontMaterial_${i}`;
      const l = new y(r, s);
      r.name = `EJCubeMask_FrontMesh_${i}`, l.frustumCulled = !1, i === 0 ? l.position.z = 0.5 : i === 1 ? (l.position.x = 0.5, l.rotation.y = Math.PI * 0.5) : i === 2 ? (l.position.z = -0.5, l.rotation.y = Math.PI) : i === 3 ? (l.position.x = -0.5, l.rotation.y = -Math.PI * 0.5) : i === 4 ? (l.position.y = 0.5, l.rotation.x = -Math.PI * 0.5) : i === 5 && (l.position.y = -0.5, l.rotation.x = Math.PI * 0.5), this.cubeFrontFaces.push(l), this.cubeFront.add(l);
    }
    this.container.add(this.cubeFront);
  }
  setFaceColorMask(e, t) {
    const i = this.cubeFrontFaces[e];
    i.material.color.r = t.x, i.material.color.g = t.y, i.material.color.b = t.z;
  }
  update(e, t) {
  }
  /**
   * Gets the screenspace box of the current context.
   *
   * @param {PerspectiveCamera} camera Camera to transform the bounding box with
   * @return {Box2} Bounding box of the mesh
   */
  getScreenspaceBox(e) {
    const t = this.cubeBack, i = t.geometry.attributes.position.array, n = new THREE.Vector3(), r = new THREE.Vector3(1, 1, 1), s = new THREE.Vector3(-1, -1, -1), l = new THREE.Vector3();
    for (let c = 0; c < i.length; c += 3) {
      l.set(...i.slice(c, c + 3));
      const C = n.copy(l).applyMatrix4(t.matrixWorld).project(e);
      r.min(C), s.max(C);
    }
    return new THREE.Box2(r, s);
  }
}
class Je {
  constructor(e, t) {
    this.container = e, this.camera = t, this.texture = new de().load("./libs/ejx/assets/env/deathstar-bourgeois.jpg", this.textureLoaded.bind(this)), this.texture.encoding = N, this.geometry = new V(1, 1, 1, 1), this.geometry.name = "EJEnvGeometry", this.material = new z({
      name: "EJEnvMaterial",
      map: this.texture,
      color: new k(16777215),
      opacity: 1,
      transparent: !1,
      depthTest: !1,
      depthWrite: !1
    }), this.plane = new y(this.geometry, this.material), this.plane.name = "EJEnvMesh", this.plane.rotation.y = -Math.PI, this.plane.visible = !1, this.container.add(this.plane);
  }
  textureLoaded(e) {
    this.textureWidth = e.image.width, this.textureHeight = e.image.height, this.textureAspect = this.textureWidth / this.textureHeight, this.plane.visible = !0;
  }
  fitPlaneToScreen(e, t, i) {
    let r = 1 * 0.5 / Math.tan(t.fov * 0.5 * (Math.PI / 180)), s = new h();
    t.getWorldDirection(s), e.position.set(t.position.x, t.position.y, t.position.z), e.position.add(s.multiplyScalar(r)), e.rotation.setFromRotationMatrix(t.matrix), e.scale.set(i, 1, 1);
  }
  update() {
    this.fitPlaneToScreen(this.plane, this.camera, this.textureAspect);
  }
}
const qe = "None", Qe = "Image";
class Ke {
  constructor(e, t, i) {
    this.container = e, this.camera = t, this.texture = i, this.textureWidth = window.innerWidth, this.textureHeight = window.innerHeight, this.textureAspect = this.textureWidth / this.textureHeight, this.geometry = new V(1, 1, 1, 1), this.geometry.name = "EJEnvCameraGeometry", this.material = new z({
      name: "EJEnvCameraMaterial",
      map: this.texture,
      color: new k(16777215),
      opacity: 1,
      transparent: !1,
      depthTest: !1,
      depthWrite: !1
    }), this.plane = new y(this.geometry, this.material), this.plane.rotation.y = -Math.PI, this.container.add(this.plane);
  }
  fitPlaneToScreen(e, t, i) {
    let r = 1 * 0.5 / Math.tan(t.fov * 0.5 * (Math.PI / 180)), s = new h();
    t.getWorldDirection(s), e.position.set(t.position.x, t.position.y, t.position.z), e.position.add(s.multiplyScalar(r)), e.rotation.setFromRotationMatrix(t.matrix), e.scale.set(i, 1, 1);
  }
  update() {
    this.fitPlaneToScreen(this.plane, this.camera, this.textureAspect);
  }
}
const W = {
  uniforms: {
    tDiffuse: { value: null },
    opacity: { value: 1 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`
  )
};
class H {
  constructor() {
    this.enabled = !0, this.needsSwap = !0, this.clear = !1, this.renderToScreen = !1;
  }
  setSize() {
  }
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {
  }
}
const $e = new me(-1, 1, 1, -1, 0, 1), X = new ue();
X.setAttribute("position", new F([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
X.setAttribute("uv", new F([0, 2, 0, 0, 2, 0], 2));
class pe {
  constructor(e) {
    this._mesh = new y(X, e), this._mesh.frustumCulled = !1;
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, $e);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class ve extends H {
  constructor(e, t) {
    super(), this.textureID = t !== void 0 ? t : "tDiffuse", e instanceof B ? (this.uniforms = e.uniforms, this.material = e) : e && (this.uniforms = j.clone(e.uniforms), this.material = new B({
      defines: Object.assign({}, e.defines),
      uniforms: this.uniforms,
      vertexShader: e.vertexShader,
      fragmentShader: e.fragmentShader
    })), this.fsQuad = new pe(this.material);
  }
  render(e, t, i) {
    this.uniforms[this.textureID] && (this.uniforms[this.textureID].value = i.texture), this.fsQuad.material = this.material, this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(t), this.clear && e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil), this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class le extends H {
  constructor(e, t) {
    super(), this.scene = e, this.camera = t, this.clear = !0, this.needsSwap = !1, this.inverse = !1;
  }
  render(e, t, i) {
    const n = e.getContext(), r = e.state;
    r.buffers.color.setMask(!1), r.buffers.depth.setMask(!1), r.buffers.color.setLocked(!0), r.buffers.depth.setLocked(!0);
    let s, l;
    this.inverse ? (s = 0, l = 1) : (s = 1, l = 0), r.buffers.stencil.setTest(!0), r.buffers.stencil.setOp(n.REPLACE, n.REPLACE, n.REPLACE), r.buffers.stencil.setFunc(n.ALWAYS, s, 4294967295), r.buffers.stencil.setClear(l), r.buffers.stencil.setLocked(!0), e.setRenderTarget(i), this.clear && e.clear(), e.render(this.scene, this.camera), e.setRenderTarget(t), this.clear && e.clear(), e.render(this.scene, this.camera), r.buffers.color.setLocked(!1), r.buffers.depth.setLocked(!1), r.buffers.stencil.setLocked(!1), r.buffers.stencil.setFunc(n.EQUAL, 1, 4294967295), r.buffers.stencil.setOp(n.KEEP, n.KEEP, n.KEEP), r.buffers.stencil.setLocked(!0);
  }
}
class Ye extends H {
  constructor() {
    super(), this.needsSwap = !1;
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class Xe {
  constructor(e, t) {
    if (this.renderer = e, t === void 0) {
      const i = e.getSize(new g());
      this._pixelRatio = e.getPixelRatio(), this._width = i.width, this._height = i.height, t = new S(this._width * this._pixelRatio, this._height * this._pixelRatio), t.texture.name = "EffectComposer.rt1";
    } else
      this._pixelRatio = 1, this._width = t.width, this._height = t.height;
    this.renderTarget1 = t, this.renderTarget2 = t.clone(), this.renderTarget2.texture.name = "EffectComposer.rt2", this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2, this.renderToScreen = !0, this.passes = [], this.copyPass = new ve(W), this.clock = new fe();
  }
  swapBuffers() {
    const e = this.readBuffer;
    this.readBuffer = this.writeBuffer, this.writeBuffer = e;
  }
  addPass(e) {
    this.passes.push(e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  insertPass(e, t) {
    this.passes.splice(t, 0, e), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
  }
  removePass(e) {
    const t = this.passes.indexOf(e);
    t !== -1 && this.passes.splice(t, 1);
  }
  isLastEnabledPass(e) {
    for (let t = e + 1; t < this.passes.length; t++)
      if (this.passes[t].enabled)
        return !1;
    return !0;
  }
  render(e) {
    e === void 0 && (e = this.clock.getDelta());
    const t = this.renderer.getRenderTarget();
    let i = !1;
    for (let n = 0, r = this.passes.length; n < r; n++) {
      const s = this.passes[n];
      if (s.enabled !== !1) {
        if (s.renderToScreen = this.renderToScreen && this.isLastEnabledPass(n), s.render(this.renderer, this.writeBuffer, this.readBuffer, e, i), s.needsSwap) {
          if (i) {
            const l = this.renderer.getContext(), c = this.renderer.state.buffers.stencil;
            c.setFunc(l.NOTEQUAL, 1, 4294967295), this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, e), c.setFunc(l.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        le !== void 0 && (s instanceof le ? i = !0 : s instanceof Ye && (i = !1));
      }
    }
    this.renderer.setRenderTarget(t);
  }
  reset(e) {
    if (e === void 0) {
      const t = this.renderer.getSize(new g());
      this._pixelRatio = this.renderer.getPixelRatio(), this._width = t.width, this._height = t.height, e = this.renderTarget1.clone(), e.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.renderTarget1 = e, this.renderTarget2 = e.clone(), this.writeBuffer = this.renderTarget1, this.readBuffer = this.renderTarget2;
  }
  setSize(e, t) {
    this._width = e, this._height = t;
    const i = this._width * this._pixelRatio, n = this._height * this._pixelRatio;
    this.renderTarget1.setSize(i, n), this.renderTarget2.setSize(i, n);
    for (let r = 0; r < this.passes.length; r++)
      this.passes[r].setSize(i, n);
  }
  setPixelRatio(e) {
    this._pixelRatio = e, this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(), this.renderTarget2.dispose(), this.copyPass.dispose();
  }
}
const ce = {
  shaderID: "luminosityHighPass",
  uniforms: {
    tDiffuse: { value: null },
    luminosityThreshold: { value: 1 },
    smoothWidth: { value: 1 },
    defaultColor: { value: new k(0) },
    defaultOpacity: { value: 0 }
  },
  vertexShader: (
    /* glsl */
    `

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = vec4( position, 1.0 );

		}`
  ),
  fragmentShader: (
    /* glsl */
    `

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`
  )
};
class I extends H {
  constructor(e, t, i, n) {
    super(), this.strength = t !== void 0 ? t : 1, this.radius = i, this.threshold = n, this.resolution = e !== void 0 ? new g(e.x, e.y) : new g(256, 256), this.clearColor = new k(0, 0, 0), this.renderTargetsHorizontal = [], this.renderTargetsVertical = [], this.nMips = 5;
    let r = Math.round(this.resolution.x / 2), s = Math.round(this.resolution.y / 2);
    this.renderTargetBright = new S(r, s), this.renderTargetBright.texture.name = "UnrealBloomPass.bright", this.renderTargetBright.texture.generateMipmaps = !1;
    for (let p = 0; p < this.nMips; p++) {
      const d = new S(r, s);
      d.texture.name = "UnrealBloomPass.h" + p, d.texture.generateMipmaps = !1, this.renderTargetsHorizontal.push(d);
      const m = new S(r, s);
      m.texture.name = "UnrealBloomPass.v" + p, m.texture.generateMipmaps = !1, this.renderTargetsVertical.push(m), r = Math.round(r / 2), s = Math.round(s / 2);
    }
    ce === void 0 && console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");
    const l = ce;
    this.highPassUniforms = j.clone(l.uniforms), this.highPassUniforms.luminosityThreshold.value = n, this.highPassUniforms.smoothWidth.value = 0.01, this.materialHighPassFilter = new B({
      uniforms: this.highPassUniforms,
      vertexShader: l.vertexShader,
      fragmentShader: l.fragmentShader,
      defines: {}
    }), this.separableBlurMaterials = [];
    const c = [3, 5, 7, 9, 11];
    r = Math.round(this.resolution.x / 2), s = Math.round(this.resolution.y / 2);
    for (let p = 0; p < this.nMips; p++)
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(c[p])), this.separableBlurMaterials[p].uniforms.texSize.value = new g(r, s), r = Math.round(r / 2), s = Math.round(s / 2);
    this.compositeMaterial = this.getCompositeMaterial(this.nMips), this.compositeMaterial.uniforms.blurTexture1.value = this.renderTargetsVertical[0].texture, this.compositeMaterial.uniforms.blurTexture2.value = this.renderTargetsVertical[1].texture, this.compositeMaterial.uniforms.blurTexture3.value = this.renderTargetsVertical[2].texture, this.compositeMaterial.uniforms.blurTexture4.value = this.renderTargetsVertical[3].texture, this.compositeMaterial.uniforms.blurTexture5.value = this.renderTargetsVertical[4].texture, this.compositeMaterial.uniforms.bloomStrength.value = t, this.compositeMaterial.uniforms.bloomRadius.value = 0.1, this.compositeMaterial.needsUpdate = !0;
    const w = [1, 0.8, 0.6, 0.4, 0.2];
    this.compositeMaterial.uniforms.bloomFactors.value = w, this.bloomTintColors = [new h(1, 1, 1), new h(1, 1, 1), new h(1, 1, 1), new h(1, 1, 1), new h(1, 1, 1)], this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, W === void 0 && console.error("THREE.UnrealBloomPass relies on CopyShader");
    const C = W;
    this.copyUniforms = j.clone(C.uniforms), this.copyUniforms.opacity.value = 1, this.materialCopy = new B({
      uniforms: this.copyUniforms,
      vertexShader: C.vertexShader,
      fragmentShader: C.fragmentShader,
      blending: we,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0
    }), this.enabled = !0, this.needsSwap = !1, this._oldClearColor = new k(), this.oldClearAlpha = 1, this.basic = new z({ transparent: !0 }), this.fsQuad = new pe(null);
  }
  dispose() {
    for (let e = 0; e < this.renderTargetsHorizontal.length; e++)
      this.renderTargetsHorizontal[e].dispose();
    for (let e = 0; e < this.renderTargetsVertical.length; e++)
      this.renderTargetsVertical[e].dispose();
    this.renderTargetBright.dispose();
  }
  setSize(e, t) {
    let i = Math.round(e / 2), n = Math.round(t / 2);
    this.renderTargetBright.setSize(i, n);
    for (let r = 0; r < this.nMips; r++)
      this.renderTargetsHorizontal[r].setSize(i, n), this.renderTargetsVertical[r].setSize(i, n), this.separableBlurMaterials[r].uniforms.texSize.value = new g(i, n), i = Math.round(i / 2), n = Math.round(n / 2);
  }
  render(e, t, i, n, r) {
    window.spector && window.spector.setMarker("Effect: Bloom"), e.getClearColor(this._oldClearColor), this.oldClearAlpha = e.getClearAlpha();
    const s = e.autoClear;
    e.autoClear = !1, e.setClearColor(this.clearColor, 0), r && e.state.buffers.stencil.setTest(!1), this.renderToScreen && (this.fsQuad.material = this.basic, this.basic.map = i.texture, e.setRenderTarget(null), e.clear(), this.fsQuad.render(e)), this.highPassUniforms.tDiffuse.value = i.texture, this.highPassUniforms.luminosityThreshold.value = this.threshold, this.fsQuad.material = this.materialHighPassFilter, e.setRenderTarget(this.renderTargetBright), e.clear(), this.fsQuad.render(e);
    let l = this.renderTargetBright;
    for (let c = 0; c < this.nMips; c++)
      this.fsQuad.material = this.separableBlurMaterials[c], this.separableBlurMaterials[c].uniforms.colorTexture.value = l.texture, this.separableBlurMaterials[c].uniforms.direction.value = I.BlurDirectionX, e.setRenderTarget(this.renderTargetsHorizontal[c]), e.clear(), this.fsQuad.render(e), this.separableBlurMaterials[c].uniforms.colorTexture.value = this.renderTargetsHorizontal[c].texture, this.separableBlurMaterials[c].uniforms.direction.value = I.BlurDirectionY, e.setRenderTarget(this.renderTargetsVertical[c]), e.clear(), this.fsQuad.render(e), l = this.renderTargetsVertical[c];
    this.fsQuad.material = this.compositeMaterial, this.compositeMaterial.uniforms.bloomStrength.value = this.strength, this.compositeMaterial.uniforms.bloomRadius.value = this.radius, this.compositeMaterial.uniforms.bloomTintColors.value = this.bloomTintColors, e.setRenderTarget(this.renderTargetsHorizontal[0]), e.clear(), this.fsQuad.render(e), this.fsQuad.material = this.materialCopy, this.copyUniforms.tDiffuse.value = this.renderTargetsHorizontal[0].texture, r && e.state.buffers.stencil.setTest(!0), this.renderToScreen ? (e.setRenderTarget(null), this.fsQuad.render(e)) : (e.setRenderTarget(i), this.fsQuad.render(e)), e.setClearColor(this._oldClearColor, this.oldClearAlpha), e.autoClear = s;
  }
  getSeperableBlurMaterial(e) {
    return new B({
      defines: {
        KERNEL_RADIUS: e,
        SIGMA: e
      },
      uniforms: {
        colorTexture: { value: null },
        texSize: { value: new g(0.5, 0.5) },
        direction: { value: new g(0.5, 0.5) }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = vec4( position, 1.0 );
				}`,
      fragmentShader: `#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum);
				}`
    });
  }
  getCompositeMaterial(e) {
    return new B({
      defines: {
        NUM_MIPS: e
      },
      uniforms: {
        blurTexture1: { value: null },
        blurTexture2: { value: null },
        blurTexture3: { value: null },
        blurTexture4: { value: null },
        blurTexture5: { value: null },
        dirtTexture: { value: null },
        bloomStrength: { value: 1 },
        bloomFactors: { value: null },
        bloomTintColors: { value: null },
        bloomRadius: { value: 0 }
      },
      vertexShader: `varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = vec4( position, 1.0 );
				}`,
      fragmentShader: `varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform sampler2D dirtTexture;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`
    });
  }
}
I.BlurDirectionX = new g(1, 0);
I.BlurDirectionY = new g(0, 1);
class Ze {
  constructor(e, t, i, n = null) {
    this.gui = n, e.type === "bloom" && this.initBloom(e, t, i, n);
  }
  initBloom(e, t, i, n) {
    const r = new Xe(t, i);
    r.renderToScreen = !1, r.swapBuffers();
    const s = new I(
      new THREE.Vector2(i.width, i.height),
      e.bloomStrength,
      e.bloomRadius,
      e.bloomThreshold
    );
    s.needsSwap = !1, r.addPass(s);
    const l = new ve(W);
    l.needsSwap = !1, r.addPass(l), n && (n.add(e, "exposure", 0.1, e.exposure).onChange(function(c) {
      t.toneMappingExposure = Math.pow(c, 4);
    }), n.add(e, "bloomThreshold", 0, 1).onChange(function(c) {
      s.threshold = Number(c);
    }), n.add(e, "bloomStrength", 0, 5).onChange(function(c) {
      s.strength = Number(c);
    }), n.add(e, "bloomRadius", 0, 2).step(0.01).onChange(function(c) {
      s.radius = Number(c);
    })), this.renderer = t, this.composer = r;
  }
  render() {
    this.renderer.xr.enabled = !1, window.spector && window.spector.setMarker("Post processing"), this.composer.render(), window.spector && window.spector.setMarker("END: Post processing"), this.renderer.xr.enabled = !0;
  }
  resize(e, t) {
    this.composer.setSize(e, t);
  }
  dispose() {
    this.composer.renderTarget2.dispose(), this.composer.copyPass.dispose(), this.composer.passes.forEach((e) => {
      e.dispose();
    }), this.gui && this.gui.destroy();
  }
}
Te.enabled = !0;
class R {
  /**
   * @param {EJPlayerConfig} config Config for EJPlayer
   */
  constructor(e) {
    if (R.Instance)
      return R.Instance;
    R.Instance = this, this.config = e, this.config == null && (this.config = {
      gui: null
    }), this.devicePixelRatioMax = window.devicePixelRatio;
    const t = window.innerWidth, i = window.innerHeight, n = Math.min(window.devicePixelRatio, this.devicePixelRatioMax);
    this.res = new g(t, i), this.resRetina = new g(t * n, i * n), console.log("devicePixelRatio: " + window.devicePixelRatio + ". Reducing to devicePixelRatioMax: " + n), this.play = 1, this.time = 0, this.clock = new fe(!1), this.contents = [], this.contentConfigOriginal = [], this.contentConfigCurrent = [], this.contentConfigInside = null, this.contentFaceOverrides = [], this.cameraInsideCube = {
      inside: !1,
      insideChanged: !1,
      insideFaceIndex: -1,
      px: !1,
      // positive x flag
      nx: !1,
      // negative x flag
      py: !1,
      // positive y flag
      ny: !1,
      // negative y flag
      pz: !1,
      // positive z flag
      nz: !1
      // negative z flag
    }, this.renderOverrideFunc = null, this.resizeOverrideFunc = null, this.clippingPlanesEmpty = Object.freeze([]), this.clippingPlanesCube = [];
    const r = x.getFaceNormals();
    for (let s = 0; s < r.length; s++) {
      const l = r[s], c = new ye(l, 0.51);
      this.clippingPlanesCube.push(c);
    }
    this.saveImageFlag = !1, this.init(this.config), this.render();
  }
  /**
   * @param {EJPlayerConfig} config
   */
  init(e) {
    const { canvas: t, renderer: i, camera: n, scene: r, cameraTexture: s } = e;
    this.canvas = t || document.createElement("canvas"), this.canvas.id = "ej-renderer";
    let l = this.canvas.getContext("webgl2");
    i != null ? this.renderer = i : (this.renderer = new Fe({
      canvas: this.canvas,
      context: l,
      alpha: !0,
      antialias: !0
    }), this.renderer.setSize(this.res.x, this.res.y), this.renderer.setPixelRatio(this.resRetina.x / this.res.x), this.renderer.setClearColor(0, 0), this.renderer.autoClear = !1, this.renderer.clippingPlanes = this.clippingPlanesEmpty, this.renderer.xr.enabled = !0, this.renderer.outputEncoding = N, this.renderer.toneMapping = ke, this.renderer.toneMappingExposure = 1, this.renderer.useLegacyLights = !1), t || document.body.appendChild(this.renderer.domElement), n != null ? this.camera = n : (this.camera = new Be(20, this.res.x / this.res.y, 0.01, 1e3), this.camera.position.set(0, 0, 5), this.camera.lookAt(0, 0, 0)), this.camera.name = "xrCamera", this.cameraTestMesh = null, this.cameraTest = this.camera, this.orbitControls = new Re(this.camera, this.renderer.domElement), this.orbitControls.enableDamping = !0, this.orbitControls.minDistance = 0, this.orbitControls.maxDistance = 10, r != null ? this.scene = r : (this.scene = new G(), this.scene.background = null), s != null ? this.cameraTexture = s : this.cameraTexture = null, this.initCommon(), this.cubeInit(A), this.inputEventsInit(), window.addEventListener("resize", this.resizeHandler.bind(this)), this.renderer.setAnimationLoop(this.animationLoop.bind(this));
  }
  initCommon() {
    this.renderTargetContent = new S(this.resRetina.x, this.resRetina.y, {
      wrapS: ie,
      wrapT: ie,
      magFilter: re,
      minFilter: re,
      generateMipmaps: !1,
      format: Pe,
      type: Ie,
      anisotropy: De.anisotropy,
      encoding: N,
      depthBuffer: !0,
      stencilBuffer: !0,
      samples: 0
    }), this.renderTargetContentMasked = this.renderTargetContent.clone(), this.renderTargetMask = this.renderTargetContent.clone(), this.renderTargetContent.texture.name = "EJ.renderTargetContent", this.renderTargetContentMasked.texture.name = "EJ.renderTargetContentMasked", this.renderTargetMask.texture.name = "EJ.renderTargetMask", this.renderTargets = [
      this.renderTargetContent,
      this.renderTargetContentMasked,
      this.renderTargetMask
    ], this.cubeMasterOpacity = 1, this.cubeMasterOpacitySaved = 1, this.cubeContainer = new E(), this.scene.add(this.cubeContainer), this.cubeMask = new je(new E(), null), this.cubeMaskScene = new G(), this.cubeMaskScene.add(this.cubeMask.container), this.cubeMaskPass = this.initMaskPass(), this.cubeMaskPassCamera = new me(-1, 1, 1, -1, 0, 1), this.loadingManager = new THREE.LoadingManager(), this.postProcessing = null;
  }
  initMaskPass() {
    const e = new V(2, 2), t = new B({
      uniforms: {
        texContent: { type: "t", value: this.renderTargetContent.texture },
        texMask: { type: "t", value: this.renderTargetMask.texture },
        color: { value: new h(0, 0, 0) }
      },
      vertexShader: `
        varying vec2 vUv;
        void main(){ 
          vUv = uv;
          gl_Position = vec4( position, 1.0 );
        }
      `,
      fragmentShader: `
        uniform sampler2D texContent;
        uniform sampler2D texMask;
        uniform vec3 color;
        varying vec2 vUv;
        
        void main(){
          vec4 colorMask = texture2D( texMask, vUv);
          if(colorMask.r == color.r && colorMask.g == color.g && colorMask.b == color.b) {
            gl_FragColor = texture2D( texContent, vUv);
            return;
          }
          discard;
        }
      `
    }), i = new y(e, t);
    return i.name = "EJPlayer_MaskPassMesh", i.frustumCulled = !1, i;
  }
  animationLoop(e, t) {
    if (this.renderOverrideFunc !== null) {
      this.renderOverrideFunc(e, t);
      return;
    }
    this.render(e, t);
  }
  render(e, t) {
    this.clock.running == !1 && this.clock.start();
    let i = this.clock.getDelta();
    i *= this.play, this.time += i, this.orbitControls && this.orbitControls.update(), this.cameraTestMesh || (this.cameraTestMesh = new y(), this.cameraTestMesh.frustumCulled = !1, this.cameraTestMesh.onBeforeRender = (v, T, M, D, b, Z) => {
      this.cameraTest = M;
    }), this.renderer.render(this.cameraTestMesh, this.camera), this.envUpdate(), this.cubeUpdate(this.cameraTest);
    const n = new Ee();
    n.copy(this.cubeContainer.matrixWorld).invert();
    const r = new h(this.cameraTest.position.x, this.cameraTest.position.y, this.cameraTest.position.z);
    r.applyMatrix4(n);
    const s = 0.5, l = s + 0.1, c = r.x <= s, w = r.x >= -s, C = r.y <= s, p = r.y >= -s, d = r.z <= s, m = r.z >= -s, f = c && w && C && p && d && m, o = r.x <= l && r.x >= -l && r.y <= l && r.y >= -l && r.z <= l && r.z >= -l;
    this.cameraInsideCube.insideChanged = this.cameraInsideCube.inside != f, this.cameraInsideCube.inside = f, this.cameraInsideCube.insidePad = o, this.cameraInsideCube.insideChanged && this.cameraInsideCube.inside && (this.cameraInsideCube.px != c ? this.cameraInsideCube.insideFaceIndex = 1 : this.cameraInsideCube.nx != w ? this.cameraInsideCube.insideFaceIndex = 3 : this.cameraInsideCube.py != C ? this.cameraInsideCube.insideFaceIndex = 4 : this.cameraInsideCube.ny != p ? this.cameraInsideCube.insideFaceIndex = 5 : this.cameraInsideCube.pz != d ? this.cameraInsideCube.insideFaceIndex = 0 : this.cameraInsideCube.nz != m && (this.cameraInsideCube.insideFaceIndex = 2)), this.cameraInsideCube.px = c, this.cameraInsideCube.nx = w, this.cameraInsideCube.py = C, this.cameraInsideCube.ny = p, this.cameraInsideCube.pz = d, this.cameraInsideCube.nz = m;
    const u = this.contentCurrent();
    u ? this.renderContent(u) : this.renderer.render(this.scene, this.camera);
  }
  renderContent(e) {
    if (!e.instance)
      return;
    if (!e.instance.render) {
      console.log("content.instance.render does not exist.");
      return;
    }
    let t = !0;
    if (t = t && !this.postProcessing, t = t && e.instance.postProcessing, t) {
      const o = e.instance.postProcessing();
      if (o) {
        let u = null;
        this.config.gui && (u = this.config.gui.addFolder("Post Processing")), this.postProcessing = new Ze(
          o,
          this.renderer,
          this.renderTargetContent,
          u
        );
      }
    }
    if (!this.cube) {
      this.renderer.render(this.scene, this.camera), e.instance.update && e.instance.update(), e.instance.render();
      return;
    }
    const i = this.renderer.getRenderTarget();
    i && this.renderer.xr.isPresenting && this.resize(i.width, i.height, window.devicePixelRatio, !0), e.camera.copy(this.camera), e.scene.position.copy(this.cubeContainer.position), e.scene.quaternion.copy(this.cubeContainer.quaternion), e.scene.scale.copy(this.cubeContainer.scale);
    let n = this.renderer.clippingPlanes.length > 0, r = !1;
    e.instance.useClippingPlanes && (r = e.instance.useClippingPlanes()), r !== n && (r ? this.renderer.clippingPlanes = this.clippingPlanesCube : this.renderer.clippingPlanes = this.clippingPlanesEmpty);
    const l = x.getFaceNormals(), c = x.getFaceCentres(), w = x.getFaceCentres(), C = new ne(new g(0, 0), new g(this.resRetina.x, this.resRetina.y)), p = [], d = new Se().getNormalMatrix(this.cubeContainer.matrixWorld);
    for (let o = 0; o < l.length; o++)
      l[o].applyMatrix3(d).normalize();
    for (let o = 0; o < c.length; o++)
      c[o].applyMatrix4(this.cubeContainer.matrixWorld);
    for (let o = 0; o < 6; o++)
      if (this.cameraTest.position.clone().sub(c[o]).dot(l[o]) > 0 !== !1) {
        if (this.cameraInsideCube.insidePad === !1) {
          const T = [
            new h(-0.5, 0.5, 0),
            new h(0.5, 0.5, 0),
            new h(0.5, -0.5, 0),
            new h(-0.5, -0.5, 0)
          ], M = new ne();
          if (T.forEach((b) => {
            o === 0 || (o === 1 ? b.applyAxisAngle(new h(0, 1, 0), Math.PI * 0.5) : o === 2 ? b.applyAxisAngle(new h(0, 1, 0), Math.PI) : o === 3 ? b.applyAxisAngle(new h(0, 1, 0), -Math.PI * 0.5) : o === 4 ? b.applyAxisAngle(new h(1, 0, 0), -Math.PI * 0.5) : o === 5 && b.applyAxisAngle(new h(1, 0, 0), Math.PI * 0.5)), b.add(w[o]), b.applyMatrix4(this.cubeContainer.matrixWorld), b.project(this.cameraTest), b.x = (b.x + 1) * this.resRetina.x * 0.5, b.y = -(b.y - 1) * this.resRetina.y * 0.5, b.z = 0, M.expandByPoint(new g(b.x, b.y));
          }), M.intersectsBox(C) === !1)
            continue;
        }
        p.push(o);
      }
    this.cameraInsideCube.insideChanged && (this.cameraInsideCube.inside ? this.contentConfigCurrent.forEach((o) => {
      o.cubeFaceIndices.find((v) => v === this.cameraInsideCube.insideFaceIndex) !== void 0 && (this.contentConfigInside = o, this.cubeMask.cubeBackMaterial.color.r = this.contentConfigInside.colorMask.x, this.cubeMask.cubeBackMaterial.color.g = this.contentConfigInside.colorMask.y, this.cubeMask.cubeBackMaterial.color.b = this.contentConfigInside.colorMask.z);
    }) : (this.contentFaceOverrides = [], p.forEach((o) => {
      this.contentFaceOverrides.push({
        faceIndex: o,
        contentID: this.contentConfigInside.contentID,
        colorMask: this.contentConfigInside.colorMask
      });
    }), this.contentConfigInside = null));
    for (let o = 0; o < this.contentFaceOverrides.length; o++) {
      const u = this.contentFaceOverrides[o];
      p.find((T) => T === u.faceIndex) === void 0 && this.contentFaceOverrides.splice(o--, 1);
    }
    const m = x.getFaceColorMasks();
    if (this.contentConfigOriginal = [], e.instance && e.instance.contentPerCubeFace) {
      const o = e.instance.contentPerCubeFace();
      if (o) {
        const u = [];
        for (u.push({
          contentID: o.front ? o.front : 0,
          cubeFaceIndex: 0
        }), u.push({
          contentID: o.right ? o.right : 0,
          cubeFaceIndex: 1
        }), u.push({
          contentID: o.back ? o.back : 0,
          cubeFaceIndex: 2
        }), u.push({
          contentID: o.left ? o.left : 0,
          cubeFaceIndex: 3
        }), u.push({
          contentID: o.top ? o.top : 0,
          cubeFaceIndex: 4
        }), u.push({
          contentID: o.bottom ? o.bottom : 0,
          cubeFaceIndex: 5
        }); u.length > 0; ) {
          const v = u.splice(0, 1)[0], T = [v.cubeFaceIndex];
          for (let M = 0; M < u.length; M++)
            if (u[M].contentID === v.contentID) {
              const b = u.splice(M--, 1)[0];
              T.push(b.cubeFaceIndex);
            }
          this.contentConfigOriginal.push({
            contentID: v.contentID,
            cubeFaceIndices: T,
            colorMask: m.splice(0, 1)[0]
          });
        }
      }
    }
    this.contentConfigOriginal.length === 0 && (this.contentConfigOriginal = [
      {
        contentID: 0,
        cubeFaceIndices: [0, 1, 2, 3, 4, 5],
        colorMask: m[0]
      }
    ]), this.contentConfigCurrent = [], this.contentConfigOriginal.forEach((o) => {
      this.contentConfigCurrent.push({
        contentID: o.contentID,
        cubeFaceIndices: [...o.cubeFaceIndices],
        colorMask: new h().copy(o.colorMask)
      });
    }), this.contentFaceOverrides.forEach((o) => {
      this.contentConfigCurrent.forEach((v) => {
        const T = v.cubeFaceIndices.findIndex((M) => M === o.faceIndex);
        T !== -1 && v.cubeFaceIndices.splice(T, 1);
      });
      const u = this.contentConfigCurrent.find((v) => v.contentID === o.contentID);
      u !== void 0 && u.cubeFaceIndices.push(o.faceIndex);
    }), this.contentConfigCurrent.forEach((o) => {
      o.cubeFaceIndices.forEach((u) => {
        this.cubeMask.setFaceColorMask(u, o.colorMask);
      });
    }), window.spector && window.spector.setMarker("Render: Cube Mask Scene"), this.renderer.setRenderTarget(this.renderTargetMask), this.renderer.clear(), this.cubeContainer.matrixWorld.decompose(
      this.cubeMaskScene.position,
      this.cubeMaskScene.quaternion,
      this.cubeMaskScene.scale
    ), this.renderer.render(this.cubeMaskScene, this.camera);
    let f = [];
    this.contentConfigInside ? f = [this.contentConfigInside] : this.contentConfigCurrent.forEach((o) => {
      let u = !1;
      o.cubeFaceIndices.forEach((v) => {
        p.find((M) => M === v) !== void 0 && (u = !0);
      }), u && f.push(o);
    }), e.instance.update && e.instance.update();
    for (let o = 0; o < f.length; o++) {
      const u = f[o];
      window.spector && window.spector.setMarker(`Rendering ${u.contentID}`), this.renderer.setRenderTarget(this.renderTargetContent), this.renderer.clear(), e.instance.render(u.contentID), this.postProcessing && this.postProcessing.render(), this.cameraInsideCube.inside === !1 && this.cubeMask.cubeBackMaterial.color.setRGB(u.colorMask.x, u.colorMask.y, u.colorMask.z), this.cubeMaskPass.material.uniforms.color.value = u.colorMask, this.cubeMaskPass.material.uniformsNeedUpdate = !0, window.spector && window.spector.setMarker("Render: Cube Mask Pass"), this.renderer.setRenderTarget(this.renderTargetContentMasked), o == 0 && this.renderer.clear();
      const v = this.renderer.xr.enabled;
      this.renderer.xr.enabled = !1, this.renderer.render(this.cubeMaskPass, this.cubeMaskPassCamera), this.renderer.xr.enabled = v;
    }
    this.saveImageFlag && (this.saveImageFlag = !1, this.renderExterior()), this.renderer.setRenderTarget(i), window.spector && window.spector.setMarker("Rendering EJPlayer scene"), this.renderer.render(this.scene, this.camera);
  }
  renderExterior() {
    window.spector && window.spector.setMarker("Render: Exterior");
    const e = this.contentCurrent();
    if (!(e && e.instance && e.instance.render))
      return;
    const i = this.res.clone(), n = this.resRetina.x / this.res.x, r = 512;
    this.resize(r, r, 1);
    const s = this.renderTargetContent.clone();
    s.texture.name = "EJ.renderTargetFace", s.texture.encoding = he, this.cubeContainer.matrix.identity(), this.cubeContainer.matrix.decompose(
      this.cubeContainer.position,
      this.cubeContainer.quaternion,
      this.cubeContainer.scale
    ), this.cubeContainer.matrixWorld.decompose(
      this.cubeMaskScene.position,
      this.cubeMaskScene.quaternion,
      this.cubeMaskScene.scale
    ), this.cubeContainer.matrix.decompose(
      e.scene.position,
      e.scene.quaternion,
      e.scene.scale
    );
    const l = this.camera.clone(), c = this.camera.clone();
    let w = {};
    e.instance.contentPerCubeFace && (w = e.instance.contentPerCubeFace());
    const C = x.getFaceDescriptors(), p = x.getFaceNormals(), d = x.getFaceColorMasks(), m = ["pz", "px", "nz", "nx", "py", "ny"];
    for (let f = 0; f < C.length; f++) {
      const o = 0.5 / Math.tan(c.fov * 0.5 * (Math.PI / 180)) + 0.5, u = p[f];
      u.multiplyScalar(o), c.position.copy(u), c.lookAt(0, 0, 0), window.spector && window.spector.setMarker(`Cube Content ${f}`), this.camera.copy(c), e.camera.copy(c);
      const v = d[f];
      this.cubeMask.setFaceColorMask(f, v), this.cubeMask.cubeBackMaterial.color.setRGB(v.x, v.y, v.z), this.cubeMaskPass.material.uniforms.color.value = v, this.cubeMaskPass.material.uniformsNeedUpdate = !0, this.renderer.setRenderTarget(this.renderTargetMask), this.renderer.clear(), this.renderer.render(this.cubeMaskScene, c), this.renderer.setRenderTarget(this.renderTargetContent), this.renderer.clear();
      const T = C[f];
      let M = 0;
      w[T] && (M = w[T]), e.instance.render(M), this.renderer.setRenderTarget(this.renderTargetContentMasked), this.renderer.clear(), this.renderer.render(this.cubeMaskPass, this.cubeMaskPassCamera), this.renderer.setRenderTarget(s), this.renderer.clear(), this.renderer.render(this.cubeContainer, c);
      const D = new Uint8Array(r * r * 4), b = new Uint8Array(r * r * 4);
      this.renderer.readRenderTargetPixels(s, 0, 0, r, r, D);
      for (let U = 0; U < r; U++) {
        const ee = U * r * 4, ge = (r - U - 1) * r * 4;
        b.set(D.subarray(ee, ee + r * 4), ge);
      }
      const Z = m[f] + ".png";
      this.saveImage(b, r, r, Z);
    }
    s.dispose(), e.camera.copy(l), this.resize(i.x, i.y, n);
  }
  dispose() {
    this.inputEventsKill();
  }
  // -------------------------------------------------------------- save image.
  requestSaveImage() {
    this.saveImageFlag = !0;
  }
  saveImage(e, t, i, n) {
    const r = document.createElement("canvas");
    r.width = t, r.height = i;
    const s = r.getContext("2d"), l = s.createImageData(t, i);
    l.data.set(e), s.putImageData(l, 0, 0), r.toBlob((c) => {
      this.downloadImage(c, n);
    }, "image/png");
  }
  downloadImage(e, t) {
    let i = document.createElement("a");
    document.body.appendChild(i), i.download = t, i.href = URL.createObjectURL(e), i.click(), document.body.removeChild(i);
  }
  // -------------------------------------------------------------- Resize
  resize(e = window.innerWidth, t = window.innerHeight, i = window.devicePixelRatio, n = !1) {
    i = Math.min(i, this.devicePixelRatioMax);
    const r = e * i, s = t * i;
    if (this.res.x == e && this.res.y == t && this.resRetina.x == r && this.resRetina.y == s)
      return;
    this.res = new g(e, t), n ? this.resRetina = new g(e, t) : (this.resRetina = new g(r, s), this.camera.aspect = this.res.x / this.res.y, this.camera.updateProjectionMatrix(), this.renderer.setSize(this.res.x, this.res.y), this.renderer.setPixelRatio(i)), this.renderTargets.forEach((c) => {
      c.setSize(this.resRetina.x, this.resRetina.y);
    });
    const l = this.contentCurrent();
    l && l.instance && l.instance.resize && l.instance.resize(this.resRetina.x, this.resRetina.y), this.cubeUpdateProps(), this.postProcessing && this.postProcessing.resize(this.resRetina.x, this.resRetina.y);
  }
  resizeHandler() {
    if (this.resizeOverrideFunc !== null) {
      this.resizeOverrideFunc();
      return;
    }
    this.resize();
  }
  // -------------------------------------------------------------- Input Events
  inputEventsInit() {
    document.addEventListener("keydown", this.inputHandler.bind(this)), document.addEventListener("keyup", this.inputHandler.bind(this)), document.addEventListener("pointerdown", this.inputHandler.bind(this)), document.addEventListener("pointerup", this.inputHandler.bind(this)), document.addEventListener("pointermove", this.inputHandler.bind(this));
  }
  inputEventsKill() {
    document.removeEventListener("keydown", this.inputHandler.bind(this)), document.removeEventListener("keyup", this.inputHandler.bind(this)), document.removeEventListener("pointerdown", this.inputHandler.bind(this)), document.removeEventListener("pointerup", this.inputHandler.bind(this)), document.removeEventListener("pointermove", this.inputHandler.bind(this));
  }
  inputHandler(e) {
    const t = this.contentCurrent();
    t && t.instance && t.instance[e.type] && t.instance[e.type](e);
  }
  // -------------------------------------------------------------- Environment
  envKill() {
    this.env != null && (this.env.container.parent && this.env.container.parent.remove(this.env.container), this.env = null);
  }
  envCameraInit() {
    this.env = new Ke(new E(), this.camera, this.cameraTexture), this.scene.add(this.env.container);
  }
  envInit(e) {
    this.envKill(), e != qe && (e == Qe && (this.env = new Je(new E(), this.camera)), this.scene.add(this.env.container));
  }
  envUpdate() {
    this.env && this.env.update();
  }
  // -------------------------------------------------------------- Cube
  cubeKill() {
    this.cube != null && (this.cube.dispose(), this.cube = null);
  }
  cubeInit(e) {
    let t = !1;
    if (t = t || e === J, t = t || e === A, t = t || e === q, t = t || e === Q, t == !1)
      return;
    let i = !0;
    i = i && this.cube != null, i = i && this.cube.style === e, !i && (this.cubeKill(), e != J && (e == A ? this.cube = new We(this.cubeContainer, this.config.gui) : e == q ? this.cube = new Oe(this.cubeContainer, this.config.gui) : e == Q && (this.cube = new Ge(this.cubeContainer, this.config.gui)), this.cubeUpdateProps(), this.cube.updateMasterOpacity(this.cubeMasterOpacity)));
  }
  cubeUpdate(e) {
    if (this.cube == null)
      return;
    this.cube.update(e);
    const t = this.cubeMasterOpacitySaved != this.cubeMasterOpacity;
    this.cubeMasterOpacitySaved = this.cubeMasterOpacity, t && this.cube.updateMasterOpacity(this.cubeMasterOpacity);
  }
  cubeUpdateProps() {
    if (this.cube == null)
      return;
    let e = !1;
    const t = this.contentCurrent();
    t && t.instance && t.instance.canGoInsideCube && (e = t.instance.canGoInsideCube()), this.cube.updateProps(this.renderTargetContentMasked.texture, this.resRetina, e);
  }
  // -------------------------------------------------------------- Content
  contentLoaded() {
    const e = this.contentCurrent();
    return e ? e.instance && e.instance.loaded ? e.instance.loaded() : !0 : !1;
  }
  contentLoadProgress() {
    let e = 0;
    const t = this.contentCurrent();
    return t && t.instance && t.instance.loadProgress && (e = t.instance.loadProgress()), e;
  }
  contentCurrent() {
    return this.contents.length == 0 ? null : this.contents[this.contents.length - 1];
  }
  contentDispose(e) {
    e.instance && e.instance.dispose && e.instance.dispose(), e.scene && P.disposeRecursive(e.scene), e.gui && e.gui.destroy(), this.postProcessing && (this.postProcessing.dispose(), this.postProcessing = null);
  }
  contentInstantiate(e) {
    const t = this.contentCurrent();
    if (t == null)
      return;
    t.scene = new G(), t.camera = this.camera, this.config.gui && (t.gui = this.config.gui.addFolder("Content Settings"));
    const i = (n) => {
      const r = t.filename;
      return r.substring(0, r.lastIndexOf("/")) + "/" + n;
    };
    if (this.loadingManager.setURLModifier(i), t.instance = e.main({
      canvas: this.canvas,
      renderer: this.renderer,
      renderTarget: this.renderTargetContent,
      scene: t.scene,
      camera: t.camera,
      loadingManager: this.loadingManager,
      gui: t.gui
    }), t.instance && t.instance.cubeStyle) {
      const n = t.instance.cubeStyle();
      this.cubeInit(n);
    }
  }
  contentKill(e) {
    this.contentDispose(e);
  }
  contentKillAll() {
    this.contents.forEach((e) => {
      this.contentKill(e);
    }), this.contents.splice(0, this.contents.length);
  }
  contentValidate(e) {
    return !0;
  }
  // INFO: LK I've modified the implementation to support passing in the module directly.
  // I don't think the library should assume how the content will be loaded and this
  // will make everything more versatile.
  // -------------------------------------------------------------- API
  setContent({ filename: e, module: t }) {
    if (this.contentValidate(e) == !1)
      return;
    this.contentKillAll();
    const i = {
      filename: e,
      identifier: e.split(".js")[0] + "-script",
      module: t,
      instance: null,
      scene: null,
      gui: null
    };
    this.contents.push(i), this.contentInstantiate(t);
  }
  setCube(e) {
    this.cubeInit(e);
  }
  setEnvironment(e) {
    this.envInit(e);
  }
}
typeof window < "u" && (window.EJPlayer = R);
export {
  R as EJPlayer
};
