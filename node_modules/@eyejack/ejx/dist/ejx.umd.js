(function(T,n){typeof exports=="object"&&typeof module<"u"?n(exports,require("three"),require("three/examples/jsm/controls/OrbitControls.js"),require("three/examples/jsm/loaders/RGBELoader.js"),require("three/examples/jsm/geometries/RoundedBoxGeometry.js")):typeof define=="function"&&define.amd?define(["exports","three","three/examples/jsm/controls/OrbitControls.js","three/examples/jsm/loaders/RGBELoader.js","three/examples/jsm/geometries/RoundedBoxGeometry.js"],n):(T=typeof globalThis<"u"?globalThis:T||self,n(T.EJxLib={},T.three,T.OrbitControls_js,T.RGBELoader_js,T.RoundedBoxGeometry_js))})(this,function(T,n,J,q,Q){"use strict";const y=Object.create(null);y.disposeMaterial=o=>{Object.keys(o).forEach(e=>{o[e]&&o[e]!==null&&typeof o[e].dispose=="function"&&o[e].dispose()}),o.dispose()},y.disposeRecursive=o=>{for(;o.children.length>0;)K(o.children[0]),o.remove(o.children[0]);o.geometry&&o.geometry.dispose(),o.material&&(Array.isArray(o.material)?o.material.forEach(y.disposeMaterial):y.disposeMaterial(o.material))};const K=y.disposeRecursive,g=Object.create(null);g.getFaceNormals=()=>{const o=[];return o.push(new n.Vector3(0,0,1)),o.push(new n.Vector3(1,0,0)),o.push(new n.Vector3(0,0,-1)),o.push(new n.Vector3(-1,0,0)),o.push(new n.Vector3(0,1,0)),o.push(new n.Vector3(0,-1,0)),o};const $=g.getFaceNormals;g.getFaceCentres=()=>{const o=[];return o.push(new n.Vector3(0,0,.5)),o.push(new n.Vector3(.5,0,0)),o.push(new n.Vector3(0,0,-.5)),o.push(new n.Vector3(-.5,0,0)),o.push(new n.Vector3(0,.5,0)),o.push(new n.Vector3(0,-.5,0)),o};const Y=g.getFaceCentres;g.getFaceColorMasks=()=>{const o=[];return o.push(new n.Vector3(1,0,0)),o.push(new n.Vector3(0,1,0)),o.push(new n.Vector3(0,0,1)),o.push(new n.Vector3(1,0,1)),o.push(new n.Vector3(1,1,0)),o.push(new n.Vector3(0,1,1)),o},g.getFaceColorMasks,g.getFaceDescriptors=()=>{const o=[];return o.push("front"),o.push("right"),o.push("back"),o.push("left"),o.push("top"),o.push("bottom"),o},g.getFaceDescriptors,g.initCubeGeometry=()=>{const o=new n.BufferGeometry;o.name="EJCubeGeometry";const e=[];e.push(-1,-1,1),e.push(1,-1,1),e.push(-1,1,1),e.push(1,1,1),e.push(-1,-1,-1),e.push(1,-1,-1),e.push(-1,1,-1),e.push(1,1,-1);for(let h=0;h<e.length;h++)e[h]*=.5;const t=[];t.push(1,0,1,.5),t.push(1,0,1,.5),t.push(1,0,1,.5),t.push(1,0,1,.5),t.push(1,0,1,.5),t.push(1,0,1,.5),t.push(1,0,1,.5),t.push(1,0,1,.5);const i=[];i.push(0,3,2),i.push(0,1,3),i.push(1,7,3),i.push(1,5,7),i.push(5,6,7),i.push(5,4,6),i.push(4,2,6),i.push(4,0,2),i.push(2,7,6),i.push(2,3,7),i.push(4,1,0),i.push(4,5,1);const s=[],r=[];for(let h=0;h<i.length;h++){const m=i[h],f=m*3;s.push(e[f+0]),s.push(e[f+1]),s.push(e[f+2]);const c=m*4;r.push(t[c+0]),r.push(t[c+1]),r.push(t[c+2]),r.push(t[c+3])}const a=[];for(let h=0;h<6;h++)a.push(0,0),a.push(1,1),a.push(0,1),a.push(0,0),a.push(1,0),a.push(1,1);const l=[],u=$();for(let h=0;h<u.length;h++){const m=u[h];for(let f=0;f<6;f++)l.push(m.x,m.y,m.z)}const M=[],x=Y();for(let h=0;h<x.length;h++){const m=x[h];for(let f=0;f<6;f++)M.push(m.x,m.y,m.z)}const p=[];for(let h=0;h<6;h++)for(let m=0;m<6;m++)p.push(h);return o.setAttribute("position",new n.Float32BufferAttribute(s,3)),o.setAttribute("centre",new n.Float32BufferAttribute(M,3)),o.setAttribute("normal",new n.Float32BufferAttribute(l,3)),o.setAttribute("color",new n.Float32BufferAttribute(r,4)),o.setAttribute("uv",new n.Float32BufferAttribute(a,2)),o.setAttribute("face",new n.Float32BufferAttribute(p,1)),o},g.initCubeGeometry;const S="None",P="Plain",R="Glass",N="Glass3";class U{constructor(e,t){this.style=S,this.container=e,this.cubeBack=null,this.cubeFront=null,this.cubeToCameraDist=100,this.cubeToCameraDistNorm=1,this.cubeToCameraThreshold=.05,this.raycaster=new n.Raycaster,this.canGoInsideCube=!1,this.gui=t,this.gui&&(this.guiFolder=this.gui.addFolder("Cube Settings"))}updateProps(e,t,i){this.canGoInsideCube=i}updateMasterOpacity(e){}update(e){this.cubeToCameraDist=100,this.raycaster.setFromCamera(new n.Vector2(0,0),e);const t=this.raycaster.intersectObject(this.cubeFront);if(t.length>0){const s=t[0];this.cubeToCameraDist=s.distance}this.raycaster.ray.direction.multiply(new n.Vector3(-1,-1,-1));const i=this.raycaster.intersectObject(this.cubeBack);if(i.length>0){const s=i[0];this.cubeToCameraDist=-s.distance}this.cubeToCameraDistNorm=n.MathUtils.mapLinear(this.cubeToCameraDist,-this.cubeToCameraThreshold,this.cubeToCameraThreshold,-1,1),this.cubeToCameraDistNorm=n.MathUtils.clamp(this.cubeToCameraDistNorm,-1,1)}dispose(){this.container&&y.disposeRecursive(this.container),this.guiFolder&&(this.guiFolder.destroy(),this.guiFolder=null)}}function V(){return new n.RawShaderMaterial({uniforms:{backFace:{value:1},borderOn:{value:1},borderColor:{value:new n.Vector4(1,1,1,.25)},borderWidth:{value:.0025},borderFeather:{value:.5},textureOn:{value:1},texture:{type:"t",value:null},resolution:{value:new n.Vector2(0,0)},masterOpacity:{value:1}},vertexShader:`
      precision highp float;
      precision highp int;

      uniform mat4 modelMatrix;
      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;

      attribute vec3 position;
      attribute vec4 color;
      attribute vec2 uv;
      
      varying vec2 vUv;
      
      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
      }
    `,fragmentShader:`
      precision highp float;
      precision highp int;
      
      uniform int backFace;
      uniform int borderOn;
      uniform vec4 borderColor;
      uniform float borderWidth;
      uniform float borderFeather;
      uniform int textureOn;
      uniform sampler2D texture;
      uniform vec2 resolution;
      uniform float masterOpacity;
      
      varying vec2 vUv;

      vec4 alphaBlend( vec4 src, vec4 dst ) {
        float final_alpha = src.a + dst.a * (1.0 - src.a);
        if( final_alpha == 0.0 ) {
          return vec4( 0.0, 0.0, 0.0, 0.0 );
        }
        return vec4( (src.rgb * src.a + dst.rgb * dst.a * (1.0 - src.a)) / final_alpha, final_alpha);
      }

      float border(vec2 uv, float strokeWidth, float feather) {
        vec2 borderBottomLeft = smoothstep(vec2(strokeWidth * feather), vec2(strokeWidth), uv);
        vec2 borderTopRight = smoothstep(vec2(strokeWidth * feather), vec2(strokeWidth), 1.0 - uv);
        return 1.0 - borderBottomLeft.x * borderBottomLeft.y * borderTopRight.x * borderTopRight.y;
      }

      vec4 LinearTosRGB( vec4 value ) {
        return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
      }      
      
      void main()  {
        vec4 colorTex = vec4(0.0, 0.0, 0.0, 0.0);
        vec4 colorBorder = vec4(0.0, 0.0, 0.0, 0.0);
        
        if(textureOn == 1) {
          vec2 st = gl_FragCoord.xy / resolution;
          colorTex = texture2D(texture, st);
        }

        if(borderOn == 1 && borderWidth > 0.0 && borderColor.a > 0.0) {
          float line = border(vUv, borderWidth, 1.0 - borderFeather);
          colorBorder = vec4(borderColor.xyz, borderColor.a * line);
        }

        vec4 colorFinal = vec4(0.0, 0.0, 0.0, 0.0);
        if( backFace == 0 ) {
          colorFinal = alphaBlend(colorBorder, colorTex); // border first, then blend content on top.
        } else {
          colorFinal = alphaBlend(colorTex, colorBorder); // content first, then blend border on top.
        }

        colorFinal = LinearTosRGB( colorFinal );
        colorFinal.a *= masterOpacity;

        gl_FragColor = colorFinal;
      }      
    `,side:n.DoubleSide,transparent:!0})}class X extends U{constructor(e,t){super(e,t),this.style=P,this.geometry=g.initCubeGeometry(),this.materialBack=V(),this.materialFront=V(),this.cubeBack=new n.Mesh(this.geometry,this.materialBack),this.cubeBack.name="cubeBack",this.materialBack.side=n.BackSide,this.materialBack.uniforms.backFace.value=1,this.materialBack.uniforms.textureOn.value=1,this.materialBack.uniformsNeedUpdate=!0,this.cubeFront=new n.Mesh(this.geometry,this.materialFront),this.cubeFront.name="cubeFront",this.materialFront.side=n.FrontSide,this.materialFront.uniforms.backFace.value=0,this.materialFront.uniforms.textureOn.value=0,this.materialFront.uniformsNeedUpdate=!0,this.container.add(this.cubeBack),this.container.add(this.cubeFront),this.config={masterOpacity:1,borderOn:!0,borderWidth:.0025,borderFeather:.5,borderColor:new n.Color(16777215),borderAlpha:.25},this.guiFolder&&(this.guiFolder.add(this.config,"masterOpacity",0,1).name("Master Opacity").onChange(i=>{this.updateMasterOpacity(i)}),this.guiFolder.add(this.config,"borderOn").name("Border On").onChange(i=>{this.materialBack.uniforms.borderOn.value=i?1:0,this.materialBack.uniformsNeedUpdate=!0,this.materialFront.uniforms.borderOn.value=i?1:0,this.materialFront.uniformsNeedUpdate=!0}),this.guiFolder.add(this.config,"borderWidth",0,.1).name("Border Width").onChange(i=>{this.materialBack.uniforms.borderWidth.value=i,this.materialBack.uniformsNeedUpdate=!0,this.materialFront.uniforms.borderWidth.value=i,this.materialFront.uniformsNeedUpdate=!0}),this.guiFolder.add(this.config,"borderFeather",0,1).name("Border Feather").onChange(i=>{this.materialBack.uniforms.borderFeather.value=i,this.materialBack.uniformsNeedUpdate=!0,this.materialFront.uniforms.borderFeather.value=i,this.materialFront.uniformsNeedUpdate=!0}),this.guiFolder.addColor(this.config,"borderColor").name("Border Color").onChange(i=>{this.materialBack.uniforms.borderColor.value.x=i.r,this.materialBack.uniforms.borderColor.value.y=i.g,this.materialBack.uniforms.borderColor.value.z=i.b,this.materialBack.uniformsNeedUpdate=!0,this.materialFront.uniforms.borderColor.value.x=i.r,this.materialFront.uniforms.borderColor.value.y=i.g,this.materialFront.uniforms.borderColor.value.z=i.b,this.materialFront.uniformsNeedUpdate=!0}),this.guiFolder.add(this.config,"borderAlpha",0,1).name("Border Alpha").onChange(i=>{this.materialBack.uniforms.borderColor.value.w=i,this.materialBack.uniformsNeedUpdate=!0,this.materialFront.uniforms.borderColor.value.w=i,this.materialFront.uniformsNeedUpdate=!0}))}update(e){super.update(e)}updateProps(e,t,i){super.updateProps(e,t,i),this.materialBack.uniforms.resolution.value=t,this.materialBack.uniforms.texture.value=e,this.materialBack.uniformsNeedUpdate=!0,this.materialFront.uniforms.resolution.value=t,this.materialFront.uniforms.texture.value=e,this.materialFront.uniformsNeedUpdate=!0}updateMasterOpacity(e){this.materialBack.uniforms.masterOpacity.value=e,this.materialBack.uniformsNeedUpdate=!0,this.materialFront.uniforms.masterOpacity.value=e,this.materialFront.uniformsNeedUpdate=!0}}function W(){return new n.RawShaderMaterial({name:"EJCube1Material",uniforms:{mode:{value:0},time:{value:1},resolution:{value:new n.Vector2(0,0)},texture:{type:"t",value:null},tintAlpha:{value:.4},cubeToCameraDistNorm:{value:1},canGoInsideCube:{value:!1}},vertexShader:`
      precision highp float;
      precision highp int;

      uniform mat4 modelViewMatrix; // optional
      uniform mat4 projectionMatrix; // optional

      attribute vec3 position;
      attribute vec3 centre;
      attribute vec3 normal;
      attribute vec4 color;
      attribute vec2 uv;

      varying vec3 vPosition;
      varying vec4 vPositionWorld;
      varying vec3 vCentre;
      varying vec4 vCentreWorld;
      varying vec3 vNormal;
      varying vec4 vColor;
      varying vec2 vUv;

      void main() {

        vPosition = position;
        vPositionWorld = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        vCentre = centre;
        vCentreWorld = projectionMatrix * modelViewMatrix * vec4( centre, 1.0 );
        vNormal = normal;
        vColor = color;
        vUv = uv;

        gl_Position = vPositionWorld;
      }
    `,fragmentShader:`
      precision highp float;
      precision highp int;

      uniform int mode;
      uniform float time;
      uniform vec2 resolution;
      uniform sampler2D texture;
      uniform float tintAlpha;
      uniform float cubeToCameraDistNorm;
      uniform bool canGoInsideCube;

      varying vec3 vPosition;
      varying vec4 vPositionWorld;
      varying vec3 vCentre;
      varying vec4 vCentreWorld;
      varying vec3 vNormal;
      varying vec4 vColor;
      varying vec2 vUv;

      const float PI2 = 6.283185307179586;

      float map( float value, float inputMin, float inputMax, float outputMin, float outputMax ) {
        if( abs(inputMin - inputMax) < 0.00001 ) {
          return outputMin;
        } else {
          float outVal = ((value - inputMin) / (inputMax - inputMin) * (outputMax - outputMin) + outputMin);
          if(outputMax < outputMin){
            if( outVal < outputMax )outVal = outputMax;
            else if( outVal > outputMin )outVal = outputMin;
          } else {
            if( outVal > outputMax )outVal = outputMax;
            else if( outVal < outputMin )outVal = outputMin;
          }
          return outVal;
        }
      }

      vec4 alphaBlend( vec4 src, vec4 dst ) {
        float final_alpha = src.a + dst.a * (1.0 - src.a);
        if( final_alpha == 0.0 ) {
          return vec4( 0.0, 0.0, 0.0, 0.0 );
        }
        return vec4( (src.rgb * src.a + dst.rgb * dst.a * (1.0 - src.a)) / final_alpha, final_alpha);
      }

      float borders(vec2 uv, float strokeWidth) {
        vec2 borderBottomLeft = smoothstep(vec2(0.0), vec2(strokeWidth), uv);
        vec2 borderTopRight = smoothstep(vec2(0.0), vec2(strokeWidth), 1.0 - uv);
        return 1.0 - borderBottomLeft.x * borderBottomLeft.y * borderTopRight.x * borderTopRight.y;
      }

      vec4 warp( vec2 st ) {
        vec2 toCenter = vCentreWorld.xy - vPositionWorld.xy;
        float direction = (atan(toCenter.y, toCenter.x) / PI2) + 0.5;
        float length = borders(vUv, 0.028) + borders(vUv, 0.06) * 0.3;
        if( false ) { // debug.
          return vec4(direction, length, 0.0, 1.0);
        }

        vec2 dir = vec2(cos(direction * PI2), sin(direction * PI2));

        vec2 stWarp = st;
        stWarp.x += (length * 0.07) * dir.x;
        stWarp.y += (length * 0.07) * dir.y;

        return texture2D(texture, stWarp);
      }

      void main()  {

        vec2 st = gl_FragCoord.xy / resolution;
        vec4 color = vec4( 0.0, 0.0, 0.0, 0.0 );

        vec4 colorBorder = vec4( borders(vUv, 0.02) );
        if( colorBorder.a > 0.0 ) {
          colorBorder.rgb /= colorBorder.a; // premultiply alpha fix for dark shadows.
        }

        float colorTexAlphaMin = 0.5;
        float frostAlphaMax = 0.6;

        if( mode == 0 ) { // cube interior / back facing.

          vec4 colorTint = vec4( 0.0, 0.0, 0.0, tintAlpha );
          vec4 colorBorderFaded = vec4( colorBorder.rgb, colorBorder.a * 0.6 );
          
          color = alphaBlend( colorBorderFaded, colorTint );

          if( cubeToCameraDistNorm < 0.0 && canGoInsideCube ) { // below 0.0, meams we're inside the cube.
            
            vec4 colorTex = texture2D(texture, st);
            float colorTexAlpha = map( cubeToCameraDistNorm, 0.0, -0.5, colorTexAlphaMin, 1.0 );
            colorTex.a *= colorTexAlpha;

            float frostAlpha = map( cubeToCameraDistNorm, 0.0, -1.0, frostAlphaMax, 0.0 );
            vec4 frostCol = vec4(1.0, 1.0, 1.0, frostAlpha );

            color = alphaBlend( colorTex, color );
            color = alphaBlend( frostCol, color );
          }

        } else { // cube exterior / front facing.

          if( cubeToCameraDistNorm < 0.0 ) {
            discard; // below 0.0, meams we're inside the cube.
          }

          vec4 colorTex = warp( st );
          float colorTexAlpha = map( cubeToCameraDistNorm, 1.0, 0.5, 1.0, colorTexAlphaMin );
          colorTex.a *= colorTexAlpha;

          float frostAlpha = map( cubeToCameraDistNorm, 1.0, 0.0, 0.0, frostAlphaMax );
          vec4 frostCol = vec4(1.0, 1.0, 1.0, frostAlpha );

          color = colorTex;
          color = alphaBlend( frostCol, color );
          color = alphaBlend( colorBorder, color );
        }

        gl_FragColor = color;
      }
    `,side:n.DoubleSide,transparent:!0})}class Z extends U{constructor(e,t){super(e,t),this.style=R,this.geometry=g.initCubeGeometry(),this.materialBack=W(),this.materialFront=W(),this.cubeBack=new n.Mesh(this.geometry,this.materialBack),this.cubeBack.name="cubeBack",this.cubeBack.material.side=n.BackSide,this.cubeBack.material.uniforms.mode.value=0,this.cubeBack.material.uniformsNeedUpdate=!0,this.cubeFront=new n.Mesh(this.geometry,this.materialFront),this.cubeFront.name="cubeFront",this.cubeFront.material.side=n.FrontSide,this.cubeFront.material.uniforms.mode.value=1,this.cubeFront.material.uniformsNeedUpdate=!0,this.container.add(this.cubeBack),this.container.add(this.cubeFront),this.guiFolder&&(this.guiFolder.add(this.materialBack.uniforms.tintAlpha,"value",0,1).name("Tint Alpha").onChange(i=>{this.materialBack.uniforms.tintAlpha.value=i,this.materialBack.uniformsNeedUpdate=!0}),this.guiFolder.add(this,"cubeToCameraThreshold",0,1).name("Cube Threshold").onChange(i=>{this.cubeToCameraThreshold=i}))}update(e){super.update(e),this.materialBack.uniforms.cubeToCameraDistNorm.value=this.cubeToCameraDistNorm,this.materialBack.uniformsNeedUpdate=!0,this.materialFront.uniforms.cubeToCameraDistNorm.value=this.cubeToCameraDistNorm,this.materialFront.uniformsNeedUpdate=!0}updateProps(e,t,i){super.updateProps(e,t,i),this.materialBack.uniforms.resolution.value=t,this.materialBack.uniforms.texture.value=e,this.materialBack.uniforms.canGoInsideCube.value=i,this.materialBack.uniformsNeedUpdate=!0,this.materialFront.uniforms.resolution.value=t,this.materialFront.uniforms.texture.value=e,this.materialFront.uniforms.canGoInsideCube.value=i,this.materialFront.uniformsNeedUpdate=!0}dispose(){super.dispose()}}const ee=`#version 300 es
//3.00 we need for normal map calc

precision highp float;
precision highp int;

//built in
//https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram
uniform mat4 modelViewMatrix; 
uniform mat4 projectionMatrix; 
uniform vec3 cameraPosition;  
uniform mat4 viewMatrix;
uniform mat4 modelMatrix;


in vec3 position;
in vec3 centre;
in vec3 normal;
in vec3 tangent;
in vec4 color;
in vec2 uv;


out vec3 vPosWorld; //correct world space 
out vec3 vNormalWorld;
// out vec3 vTangentWorld;
// out vec3 vBitangentWorld;
out vec3 vViewDir;
out vec3 vViewPosition;
// out vec4 vColor;
out vec2 vUv;

//old
out vec3 vPosition;
out vec4 vPositionWorld;
out vec3 vCentre;
out vec4 vCentreWorld;
out vec3 vNormal;


//from THREEjs examples
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
  return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}

void main() {

  vPosWorld =  ( modelMatrix * vec4( position, 1. ) ).xyz;
  vNormalWorld = inverseTransformDirection( normal, modelMatrix );
  vViewDir = normalize(vPosWorld - cameraPosition); //?

  /*
  vTangentWorld = normalize( (vec4( tangent, 0.0 ) * modelMatrix ).xyz );
  vBitangentWorld = normalize( cross( vNormalWorld, vTangentWorld ) );
  */

  //these we need to normal map calc
  vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
  vViewPosition = - mvPosition.xyz;

  vUv = uv;

  //old vals
  //TODO DEPRECATE
  vPosition = position;
  vPositionWorld = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  vCentre = centre;
  vCentreWorld = projectionMatrix * modelViewMatrix * vec4( centre, 1.0 );
  vNormal = normal;
  // vColor = color;

  gl_Position = vPositionWorld;
}`,te=`#version 300 es

precision highp float;
precision highp int;

#define PI 3.14159
#define PI2 6.283185307179586

//built in 
//https://threejs.org/docs/#api/en/renderers/webgl/WebGLProgram
uniform vec3 cameraPosition;  
uniform mat4 viewMatrix;
uniform mat4 modelMatrix;
uniform mat4 projectionMatrix;


//from vert
in vec3 vPosWorld;
in vec3 vNormalWorld;
in vec3 vViewDir;
in vec3 vViewPosition;
in vec2 vUv; //surface uvs
// in vec4 vColor;
// in vec3 vTangentWorld;
// in vec3 vBitangentWorld;

//old
in vec3 vPosition;
in vec4 vPositionWorld;
in vec3 vCentre;
in vec4 vCentreWorld;
in vec3 vNormal;

out vec4 fragColor;



uniform int mode;  //rename to faceDir 
uniform float time;
uniform vec2 resolution;
uniform sampler2D texBack; //todo rename to transmissionSamplerMap or back texture 
uniform float cubeToCameraDistNorm;
uniform bool canGoInsideCube;

uniform float tintAlpha;
uniform vec3 tintColor; //rename to tintColor
// uniform float camFOV;

uniform sampler2D texHDRI; //equirectangular HDRI
uniform float texEnvExposure;

const float normalScale = .02;
uniform sampler2D texNormal; 


/*
float map( float value, float inputMin, float inputMax, float outputMin, float outputMax ) {
  if( abs(inputMin - inputMax) < .00001 ) {
    return outputMin;
  } else {
    float outVal = ((value - inputMin) / (inputMax - inputMin) * (outputMax - outputMin) + outputMin);
    if(outputMax < outputMin){
      if( outVal < outputMax )outVal = outputMax;
      else if( outVal > outputMin )outVal = outputMin;
    } else {
      if( outVal > outputMax )outVal = outputMax;
      else if( outVal < outputMin )outVal = outputMin;
    }
    return outVal;
  }
}

vec4 alphaBlend( vec4 src, vec4 dst ) {
  float final_alpha = src.a + dst.a * (1.0 - src.a);
  if(final_alpha == .0) {
    return vec4(.0,.0,.0,.0);
  }
  return vec4( (src.rgb * src.a + dst.rgb * dst.a * (1.0 - src.a)) / final_alpha, final_alpha);
}


float borders(vec2 uv, float strokeWidth) {
  vec2 borderBottomLeft = smoothstep(vec2(0.0), vec2(strokeWidth), uv);
  vec2 borderTopRight = smoothstep(vec2(0.0), vec2(strokeWidth), 1.0 - uv);
  return 1.0 - borderBottomLeft.x * borderBottomLeft.y * borderTopRight.x * borderTopRight.y;
}

vec4 warp( vec2 st ) {
  vec2 toCenter = vCentreWorld.xy - vPositionWorld.xy;
  float direction = (atan(toCenter.y, toCenter.x) / PI2) + 0.5;
  float length = borders(vUv, 0.028) + borders(vUv, 0.06) * 0.3;
  if( false ) { // debug.
    return vec4(direction, length, 0.0, 1.0);
  }

  vec2 dir = vec2(cos(direction * PI2), sin(direction * PI2));

  vec2 stWarp = st;
  stWarp.x += (length * 0.07) * dir.x;
  stWarp.y += (length * 0.07) * dir.y;

  return texture(texBack, stWarp);
}
*/
/*
// with pre-calc tangents
vec3 getDetailNormal2(vec3 n){ 

  float normalScale = 0.02;
  vec3 mapN = texture(texNormal, vUv ).xyz * 2. - 1.;
  mapN.xy *= normalScale;


  // #ifdef FLIP_SIDED
  //   transformedTangent = - transformedTangent;
  // #endif


  vec3 tangent = normalize( vTangentWorld );
  vec3 bitangent = normalize( vBitangentWorld );

  // #ifdef DOUBLE_SIDED
  //   tangent = tangent * faceDirection;
  //   bitangent = bitangent * faceDirection;
  // #endif
  // #if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )

  mat3 vTBN = mat3( vTangentWorld, vBitangentWorld, vNormalWorld );
  vec3 nDetailed = normalize( vTBN * mapN );



  // float faceDirection = gl_FrontFacing ? 1. : - 1.;
  // vec3 nDetailed = applyNormalMap( n, mapN, faceDirection ); 
  return nDetailed;

}
*/



//https://stackoverflow.com/questions/56625730/does-blending-work-with-the-glsl-mix-function
vec4 blend(vec4 src, vec4 dst, float alpha){ return src*alpha + dst*(1.-alpha); }

// vec3 bms(vec3 a, vec3 b){ return 1.- (1.-a)*(1.-b); }
// float bms(float a, float b){ return 1.- (1.-a)*(1.-b); }


//Equirectangular HDRI
//https://www.shadertoy.com/view/4lK3DK
vec3 getHDRI(vec3 rd){
  vec2 uv = vec2(atan(rd.z, rd.x) + PI, acos(-rd.y)) / vec2(2. * PI, PI); //TODO PI2
  vec3 col = texture(texHDRI, uv).rgb;
  //TODO: on THREEjs side
  col = pow(col, vec3(2.2)); //sRGB -> Linear, 
  col *= texEnvExposure;
  return col;
}

//Note: it will be faster with precomputed tangents. bi tangents cud be calculated from t x n
//from normalmap_pars_fragment.glsl.js
// Normal Mapping Without Precomputed Tangents
// http://www.thetenthplanet.de/archives/1180
vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {

  vec3 q0 = dFdx( eye_pos.xyz );
  vec3 q1 = dFdy( eye_pos.xyz );
  vec2 st0 = dFdx( vUv.st );
  vec2 st1 = dFdy( vUv.st );

  vec3 N = surf_norm; // normalized

  vec3 q1perp = cross( q1, N );
  vec3 q0perp = cross( N, q0 );

  vec3 T = q1perp * st0.x + q0perp * st1.x;
  vec3 B = q1perp * st0.y + q0perp * st1.y;

  float det = max( dot( T, T ), dot( B, B ) );
  float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );

  return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );

}

vec3 getDetailNormal(vec3 n){ 

  // float normalScale = 0.02;
  vec3 mapN = texture(texNormal, vUv).xyz * 2. - 1.;
  mapN.xy *= normalScale;

  //TODO check with main normal - coz we flip it also
  float faceDirection = gl_FrontFacing ? 1. : - 1.;

  vec3 normal = perturbNormal2Arb( - vViewPosition, n, mapN, faceDirection );
  return normal;
}


//back texture refration
//from transmission_pars_fragment.glsl.js
vec4 transmission(vec3 n){

  vec3 pos = vPosWorld;
  vec3 v = -vViewDir;
  float ior = 2.;  //we use different ior for refration coz it looks better
  float thickness = .05;

  //face dir==back face
  // if(mode==0) ior = 1./ior; //glass to air

  // Direction of refracted light.
  vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );

  // Compute rotation-independant scaling of the model matrix.
  vec3 modelScale;
  modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
  modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
  modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );

  // The thickness is specified in local space.
  vec3 transmissionRay =  normalize( refractionVector ) * thickness * modelScale;

  vec3 refractedRayExit = pos + transmissionRay;

  // Project refracted vector on the framebuffer, 
  // while mapping to normalized device coordinates.
  vec4 ndcPos = projectionMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
  vec2 refractionCoords = ndcPos.xy / ndcPos.w;
  refractionCoords += 1.0;
  refractionCoords /= 2.0;

  vec4 col = texture(texBack, refractionCoords.xy).xyzw;
  return col;

}


//surface shading 

//fresnel-schlick
const float EPS = 1e-3;
float dot_c(vec3 a, vec3 b){ return max(dot(a, b), EPS); } //clamped dot with min eps val
float fre(vec3 n, vec3 rayDir, float ior){
  float f0 = pow(ior - 1., 2.) / pow(ior + 1., 2.); 
  float cosTheta = dot_c(n, -rayDir);
  float f = f0 + (1.-f0) * pow(1.-cosTheta, 5.);
  return f;
}


vec4 shadeFront(vec3 p, vec3 n, vec3 rayDir){ 
  
  vec4 col = vec4(0.,0.,0.,0.); 
  vec4 ambientCol = transmission(n); //back texture refraction

  vec3 reflectedCol = getHDRI(reflect(rayDir, n));
  
  //this one is for fresnel. we have another one for refraction. coz it looks better
  float ior = 1.2;
  float f = fre(n, rayDir, ior);

  vec4 colTint = vec4(tintColor, tintAlpha);

  col = colTint;
  col = blend(ambientCol, col, ambientCol.a );   //inner material 
  col = blend(vec4(reflectedCol,1.), col, f ); //surface material 

  // col = mix(ambientCol, vec4(reflectedCol,1.), vec4(f.x) );

  return col;
}


vec4 shadeBack(vec3 p, vec3 n, vec3 rayDir){ 

  vec4 col = vec4(0.,0.,0.,0.);
  // vec4 colTint = vec4(tintColor, tintAlpha);

  vec3 reflectedCol = getHDRI(reflect(rayDir, n));
  
  float ior = 1.2;
  float f = fre(n, rayDir,ior);

  col = blend(vec4(reflectedCol, 1.), col, f );

  return col;
}



void main()  {

  vec2 uv = gl_FragCoord.xy / resolution; //screen uvs
  // bool faceDir = gl_FrontFacing;// ? 1. : - 1.;
  vec4 col = vec4(0.,0.,0.,0.);

  /*
  vec4 colBorder = vec4( borders(vUv, 0.02) );
  if( colBorder.a > 0.0 ) {
    colBorder.rgb /= colBorder.a; // premultiply alpha fix for dark shadows.
  }

  float colTexAlphaMin = 0.5;
  float frostAlphaMax = 0.6;
  */

  //Back face, cube interior 
  if( mode == 0 ) { 

/*
    vec4 colTint = vec4( tintColor, tintAlpha );
    // vec4 colBorderFaded = vec4( colBorder.rgb, colBorder.a * 0.6 );
    
    // col = alphaBlend( colBorderFaded, colTint );
    col =  colTint ;

    // below 0.0, means we're inside the cube.
    if( cubeToCameraDistNorm < 0.0 && canGoInsideCube ) { 
      
      vec4 colTex = texture(texBack, uv); //back texture?
      float colTexAlpha = map( cubeToCameraDistNorm, 0.0, -0.5, colTexAlphaMin, 1.0 );
      colTex.a *= colTexAlpha;

      // float frostAlpha = map( cubeToCameraDistNorm, 0., -1., frostAlphaMax, 0. );
      // vec4 frostCol = vec4(1., 1., 1., frostAlpha );

      col = alphaBlend( colTex, col );
      // col = alphaBlend( frostCol, col );

    }
*/
    

    vec3 p = vPosWorld;       //pos on surface
    vec3 n = -vNormalWorld;   //normal on surface: flipped for the back 
    //TODO check normal map along with this flipped normal - but its not critical

    vec3 rayDir = normalize(vViewDir); //already normalized, rename to viewDir
    vec3 nDetailed = getDetailNormal(n); //normalized

    vec4 colSurface = shadeBack(p, nDetailed, rayDir);
    col = colSurface; 

  } 

  // Front Face, cube exterior 
  else { 

    /*
    //clip front face?
    if( cubeToCameraDistNorm < 0.0 ) {
      discard; // below 0.0, means we're inside the cube.
    }

    vec4 colTex = warp( uv );

    float colTexAlpha = map( cubeToCameraDistNorm, 1., .5, 1., colTexAlphaMin );
    colTex.a *= colTexAlpha;

    float frostAlpha = map( cubeToCameraDistNorm, 1., 0., 0., frostAlphaMax );
    vec4 frostCol = vec4(1., 1., 1., frostAlpha );

    col = colTex;
    
    col = alphaBlend( frostCol, col );
    col = alphaBlend( colBorder, col );
    */

    vec3 p = vPosWorld;       //pos on surface
    vec3 n = vNormalWorld;    //normal on surface

    
    vec3 rayDir = normalize(vViewDir); //already normalized, todo renme to viewDir
    vec3 nDetailed = getDetailNormal(n); //normalized


    vec4 colSurface = shadeFront(p, nDetailed, rayDir);
    col = colSurface;
  }

  // col.xyz = pow(col.xyz, vec3(.4545) ); //gamma coorection

  fragColor = col;
}
`;class ie{constructor(){this.texLoader=null,this.rgbeLoader=null,this.pmremGenerator=null,this.texNormal=["n9.jpg","n12.jpg","n14.jpg","n16.jpg"],this.texEnv=["studio016.hdr","empty_warehouse_01_1k.hdr","hamburg_hbf_1k.hdr"],this.texRoughness=["h17.jpg","h9.jpg","h12.jpg","h14.jpg","h16.jpg"],this.texNormalId=0,this.texEnvId=0}loadNormalMap(e,t){this.texNormalId=t,this.texLoader.load("/libs/ejx/assets/normal/"+this.texNormal[t],function(i){i.encoding=n.sRGBEncoding,i.wrapS=n.RepeatWrapping,i.wrapT=n.RepeatWrapping;for(let s=0;s<e.length;s++)e[s].uniforms.texNormal.value=i,e[s].uniformsNeedUpdate=!0})}loadEnvMap(e,t){this.texEnvId=t,this.rgbeLoader.load("/libs/ejx/assets/env/"+this.texEnv[t],function(i){i.minFilter=n.NearestFilter,i.wrapS=n.RepeatWrapping,i.wrapT=n.RepeatWrapping,i.encoding=n.LinearEncoding;for(let s=0;s<e.length;s++)e[s].uniforms.texHDRI.value=i,s==0&&(e[s].uniforms.texEnvExposure.value=1),s==1&&(e[s].uniforms.texEnvExposure.value=.2),s==2&&(e[s].uniforms.texEnvExposure.value=.02),e[s].uniformsNeedUpdate=!0})}loadRoughnessMap(e,t){this.texRoughnessId=t,this.texLoader.load("/libs/ejx/assets/rough/"+this.texRoughness[t],function(i){i.encoding=n.sRGBEncoding,e.roughnessMap=i,e.needsUpdate=!0})}}function A(){return new n.RawShaderMaterial({vertexShader:ee,fragmentShader:te,uniforms:{mode:{value:0},time:{value:1},resolution:{value:new n.Vector2(0,0)},texBack:{value:null},tintColor:{value:new n.Color(0)},tintAlpha:{value:.2},texHDRI:{value:null},texEnvExposure:{value:.2},texNormal:{value:null},cubeToCameraDistNorm:{value:1},canGoInsideCube:{value:!1}},side:n.DoubleSide,transparent:!0})}class ne extends U{constructor(e,t){super(e,t),this.style=N,this.geometry=new Q.RoundedBoxGeometry(1,1,1,4,.02),this.materialBack=A(),this.materialFront=A(),this.cubeBack=new n.Mesh(this.geometry,this.materialBack),this.cubeBack.name="cubeBack",this.cubeBack.material.side=n.BackSide,this.cubeBack.material.uniforms.mode.value=0,this.cubeBack.material.uniformsNeedUpdate=!0,this.cubeFront=new n.Mesh(this.geometry,this.materialFront),this.cubeFront.name="cubeFront",this.cubeFront.material.side=n.FrontSide,this.cubeFront.material.uniforms.mode.value=1,this.cubeFront.material.uniformsNeedUpdate=!0,this.container.add(this.cubeBack),this.container.add(this.cubeFront);let i=new ie;i.texLoader=new n.TextureLoader,i.rgbeLoader=new q.RGBELoader,i.loadNormalMap([this.materialFront,this.materialBack],1),i.loadEnvMap([this.materialFront,this.materialBack],2),this.guiFolder&&(this.guiFolder.add(i,"texNormalId",0,i.texNormal.length-1).step(1).name("Normal Map").onChange(s=>{i.loadNormalMap([this.materialFront,this.materialBack],s)}),this.guiFolder.add(i,"texEnvId",0,i.texEnv.length-1).step(1).name("Env Map").onChange(s=>{i.loadEnvMap([this.materialFront,this.materialBack],s)}),this.guiFolder.add(this.materialFront.uniforms.texEnvExposure,"value",0,2).name("Env Exposure").onChange(s=>{this.materialBack.uniforms.texEnvExposure.value=s,this.materialBack.uniformsNeedUpdate=!0,this.materialFront.uniforms.texEnvExposure.value=s,this.materialFront.uniformsNeedUpdate=!0}),this.guiFolder.add(this.materialFront.uniforms.tintAlpha,"value",0,1).name("Tint Alpha").onChange(s=>{this.materialFront.uniformsNeedUpdate=!0}),this.guiFolder.addColor(this.materialFront.uniforms.tintColor,"value").name("Tint Color").onChange(s=>{this.materialFront.uniforms.tintColor.value=s,this.materialFront.uniformsNeedUpdate=!0}),this.guiFolder.add(this,"cubeToCameraThreshold",0,1).name("Cube Threshold").onChange(s=>{this.cubeToCameraThreshold=s}))}update(e){super.update(e),this.materialBack.uniforms.cubeToCameraDistNorm.value=this.cubeToCameraDistNorm,this.materialBack.uniformsNeedUpdate=!0,this.materialFront.uniforms.cubeToCameraDistNorm.value=this.cubeToCameraDistNorm,this.materialFront.uniformsNeedUpdate=!0}updateProps(e,t,i){super.updateProps(e,t,i),this.materialBack.uniforms.resolution.value=t,this.materialBack.uniforms.texBack.value=e,this.materialBack.uniforms.canGoInsideCube.value=i,this.materialBack.uniformsNeedUpdate=!0,this.materialFront.uniforms.resolution.value=t,this.materialFront.uniforms.texBack.value=e,this.materialFront.uniforms.canGoInsideCube.value=i,this.materialFront.uniformsNeedUpdate=!0}dispose(){super.dispose()}}class re{constructor(e){this.container=e,this.cubeBackGeometry=new n.BoxGeometry(1,1,1),this.cubeBackGeometry.name="EJCubeMask_BackGeometry",this.cubeBackMaterial=new n.MeshBasicMaterial({name:"EJCubeMask_BackMaterial",color:16711680,side:n.BackSide,depthWrite:!1,depthTest:!1}),this.cubeBack=new n.Mesh(this.cubeBackGeometry,this.cubeBackMaterial),this.cubeBack.name="EJCubeMask_BackMesh",this.cubeBack.frustumCulled=!1,this.container.add(this.cubeBack);const t=g.getFaceColorMasks();this.cubeFront=new n.Object3D,this.cubeFrontFaces=[];for(let i=0;i<6;i++){const s=t[i],r=new n.PlaneGeometry(1,1);r.name=`EJCubeMask_FrontGeometry_${i}`;const a=new n.MeshBasicMaterial({color:new n.Color(s.x,s.y,s.z),side:n.FrontSide,depthWrite:!1,depthTest:!1});r.name=`EJCubeMask_FrontMaterial_${i}`;const l=new n.Mesh(r,a);r.name=`EJCubeMask_FrontMesh_${i}`,l.frustumCulled=!1,i===0?l.position.z=.5:i===1?(l.position.x=.5,l.rotation.y=Math.PI*.5):i===2?(l.position.z=-.5,l.rotation.y=Math.PI):i===3?(l.position.x=-.5,l.rotation.y=-Math.PI*.5):i===4?(l.position.y=.5,l.rotation.x=-Math.PI*.5):i===5&&(l.position.y=-.5,l.rotation.x=Math.PI*.5),this.cubeFrontFaces.push(l),this.cubeFront.add(l)}this.container.add(this.cubeFront)}setFaceColorMask(e,t){const i=this.cubeFrontFaces[e];i.material.color.r=t.x,i.material.color.g=t.y,i.material.color.b=t.z}update(e,t){}getScreenspaceBox(e){const t=this.cubeBack,i=t.geometry.attributes.position.array,s=new THREE.Vector3,r=new THREE.Vector3(1,1,1),a=new THREE.Vector3(-1,-1,-1),l=new THREE.Vector3;for(let u=0;u<i.length;u+=3){l.set(...i.slice(u,u+3));const x=s.copy(l).applyMatrix4(t.matrixWorld).project(e);r.min(x),a.max(x)}return new THREE.Box2(r,a)}}class se{constructor(e,t){this.container=e,this.camera=t,this.texture=new n.TextureLoader().load("./libs/ejx/assets/env/deathstar-bourgeois.jpg",this.textureLoaded.bind(this)),this.texture.encoding=n.sRGBEncoding,this.geometry=new n.PlaneGeometry(1,1,1,1),this.geometry.name="EJEnvGeometry",this.material=new n.MeshBasicMaterial({name:"EJEnvMaterial",map:this.texture,color:new n.Color(16777215),opacity:1,transparent:!1,depthTest:!1,depthWrite:!1}),this.plane=new n.Mesh(this.geometry,this.material),this.plane.name="EJEnvMesh",this.plane.rotation.y=-Math.PI,this.plane.visible=!1,this.container.add(this.plane)}textureLoaded(e){this.textureWidth=e.image.width,this.textureHeight=e.image.height,this.textureAspect=this.textureWidth/this.textureHeight,this.plane.visible=!0}fitPlaneToScreen(e,t,i){let r=1*.5/Math.tan(t.fov*.5*(Math.PI/180)),a=new n.Vector3;t.getWorldDirection(a),e.position.set(t.position.x,t.position.y,t.position.z),e.position.add(a.multiplyScalar(r)),e.rotation.setFromRotationMatrix(t.matrix),e.scale.set(i,1,1)}update(){this.fitPlaneToScreen(this.plane,this.camera,this.textureAspect)}}const ae="None",oe="Image";class ce{constructor(e,t,i){this.container=e,this.camera=t,this.texture=i,this.textureWidth=window.innerWidth,this.textureHeight=window.innerHeight,this.textureAspect=this.textureWidth/this.textureHeight,this.geometry=new n.PlaneGeometry(1,1,1,1),this.geometry.name="EJEnvCameraGeometry",this.material=new n.MeshBasicMaterial({name:"EJEnvCameraMaterial",map:this.texture,color:new n.Color(16777215),opacity:1,transparent:!1,depthTest:!1,depthWrite:!1}),this.plane=new n.Mesh(this.geometry,this.material),this.plane.rotation.y=-Math.PI,this.container.add(this.plane)}fitPlaneToScreen(e,t,i){let r=1*.5/Math.tan(t.fov*.5*(Math.PI/180)),a=new n.Vector3;t.getWorldDirection(a),e.position.set(t.position.x,t.position.y,t.position.z),e.position.add(a.multiplyScalar(r)),e.rotation.setFromRotationMatrix(t.matrix),e.scale.set(i,1,1)}update(){this.fitPlaneToScreen(this.plane,this.camera,this.textureAspect)}}const D={uniforms:{tDiffuse:{value:null},opacity:{value:1}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		void main() {

			gl_FragColor = texture2D( tDiffuse, vUv );
			gl_FragColor.a *= opacity;


		}`};class E{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}dispose(){}}const le=new n.OrthographicCamera(-1,1,1,-1,0,1),z=new n.BufferGeometry;z.setAttribute("position",new n.Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),z.setAttribute("uv",new n.Float32BufferAttribute([0,2,0,0,2,0],2));class _{constructor(e){this._mesh=new n.Mesh(z,e),this._mesh.frustumCulled=!1}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,le)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}class O extends E{constructor(e,t){super(),this.textureID=t!==void 0?t:"tDiffuse",e instanceof n.ShaderMaterial?(this.uniforms=e.uniforms,this.material=e):e&&(this.uniforms=n.UniformsUtils.clone(e.uniforms),this.material=new n.ShaderMaterial({defines:Object.assign({},e.defines),uniforms:this.uniforms,vertexShader:e.vertexShader,fragmentShader:e.fragmentShader})),this.fsQuad=new _(this.material)}render(e,t,i){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=i.texture),this.fsQuad.material=this.material,this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(t),this.clear&&e.clear(e.autoClearColor,e.autoClearDepth,e.autoClearStencil),this.fsQuad.render(e))}dispose(){this.material.dispose(),this.fsQuad.dispose()}}class L extends E{constructor(e,t){super(),this.scene=e,this.camera=t,this.clear=!0,this.needsSwap=!1,this.inverse=!1}render(e,t,i){const s=e.getContext(),r=e.state;r.buffers.color.setMask(!1),r.buffers.depth.setMask(!1),r.buffers.color.setLocked(!0),r.buffers.depth.setLocked(!0);let a,l;this.inverse?(a=0,l=1):(a=1,l=0),r.buffers.stencil.setTest(!0),r.buffers.stencil.setOp(s.REPLACE,s.REPLACE,s.REPLACE),r.buffers.stencil.setFunc(s.ALWAYS,a,4294967295),r.buffers.stencil.setClear(l),r.buffers.stencil.setLocked(!0),e.setRenderTarget(i),this.clear&&e.clear(),e.render(this.scene,this.camera),e.setRenderTarget(t),this.clear&&e.clear(),e.render(this.scene,this.camera),r.buffers.color.setLocked(!1),r.buffers.depth.setLocked(!1),r.buffers.stencil.setLocked(!1),r.buffers.stencil.setFunc(s.EQUAL,1,4294967295),r.buffers.stencil.setOp(s.KEEP,s.KEEP,s.KEEP),r.buffers.stencil.setLocked(!0)}}class ue extends E{constructor(){super(),this.needsSwap=!1}render(e){e.state.buffers.stencil.setLocked(!1),e.state.buffers.stencil.setTest(!1)}}class de{constructor(e,t){if(this.renderer=e,t===void 0){const i=e.getSize(new n.Vector2);this._pixelRatio=e.getPixelRatio(),this._width=i.width,this._height=i.height,t=new n.WebGLRenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio),t.texture.name="EffectComposer.rt1"}else this._pixelRatio=1,this._width=t.width,this._height=t.height;this.renderTarget1=t,this.renderTarget2=t.clone(),this.renderTarget2.texture.name="EffectComposer.rt2",this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.renderToScreen=!0,this.passes=[],this.copyPass=new O(D),this.clock=new n.Clock}swapBuffers(){const e=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=e}addPass(e){this.passes.push(e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}insertPass(e,t){this.passes.splice(t,0,e),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}removePass(e){const t=this.passes.indexOf(e);t!==-1&&this.passes.splice(t,1)}isLastEnabledPass(e){for(let t=e+1;t<this.passes.length;t++)if(this.passes[t].enabled)return!1;return!0}render(e){e===void 0&&(e=this.clock.getDelta());const t=this.renderer.getRenderTarget();let i=!1;for(let s=0,r=this.passes.length;s<r;s++){const a=this.passes[s];if(a.enabled!==!1){if(a.renderToScreen=this.renderToScreen&&this.isLastEnabledPass(s),a.render(this.renderer,this.writeBuffer,this.readBuffer,e,i),a.needsSwap){if(i){const l=this.renderer.getContext(),u=this.renderer.state.buffers.stencil;u.setFunc(l.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,e),u.setFunc(l.EQUAL,1,4294967295)}this.swapBuffers()}L!==void 0&&(a instanceof L?i=!0:a instanceof ue&&(i=!1))}}this.renderer.setRenderTarget(t)}reset(e){if(e===void 0){const t=this.renderer.getSize(new n.Vector2);this._pixelRatio=this.renderer.getPixelRatio(),this._width=t.width,this._height=t.height,e=this.renderTarget1.clone(),e.setSize(this._width*this._pixelRatio,this._height*this._pixelRatio)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=e,this.renderTarget2=e.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2}setSize(e,t){this._width=e,this._height=t;const i=this._width*this._pixelRatio,s=this._height*this._pixelRatio;this.renderTarget1.setSize(i,s),this.renderTarget2.setSize(i,s);for(let r=0;r<this.passes.length;r++)this.passes[r].setSize(i,s)}setPixelRatio(e){this._pixelRatio=e,this.setSize(this._width,this._height)}dispose(){this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.copyPass.dispose()}}const G={shaderID:"luminosityHighPass",uniforms:{tDiffuse:{value:null},luminosityThreshold:{value:1},smoothWidth:{value:1},defaultColor:{value:new n.Color(0)},defaultOpacity:{value:0}},vertexShader:`

		varying vec2 vUv;

		void main() {

			vUv = uv;

			gl_Position = vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform sampler2D tDiffuse;
		uniform vec3 defaultColor;
		uniform float defaultOpacity;
		uniform float luminosityThreshold;
		uniform float smoothWidth;

		varying vec2 vUv;

		void main() {

			vec4 texel = texture2D( tDiffuse, vUv );

			vec3 luma = vec3( 0.299, 0.587, 0.114 );

			float v = dot( texel.xyz, luma );

			vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );

			float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );

			gl_FragColor = mix( outputColor, texel, alpha );

		}`};class F extends E{constructor(e,t,i,s){super(),this.strength=t!==void 0?t:1,this.radius=i,this.threshold=s,this.resolution=e!==void 0?new n.Vector2(e.x,e.y):new n.Vector2(256,256),this.clearColor=new n.Color(0,0,0),this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;let r=Math.round(this.resolution.x/2),a=Math.round(this.resolution.y/2);this.renderTargetBright=new n.WebGLRenderTarget(r,a),this.renderTargetBright.texture.name="UnrealBloomPass.bright",this.renderTargetBright.texture.generateMipmaps=!1;for(let p=0;p<this.nMips;p++){const h=new n.WebGLRenderTarget(r,a);h.texture.name="UnrealBloomPass.h"+p,h.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(h);const m=new n.WebGLRenderTarget(r,a);m.texture.name="UnrealBloomPass.v"+p,m.texture.generateMipmaps=!1,this.renderTargetsVertical.push(m),r=Math.round(r/2),a=Math.round(a/2)}G===void 0&&console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");const l=G;this.highPassUniforms=n.UniformsUtils.clone(l.uniforms),this.highPassUniforms.luminosityThreshold.value=s,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new n.ShaderMaterial({uniforms:this.highPassUniforms,vertexShader:l.vertexShader,fragmentShader:l.fragmentShader,defines:{}}),this.separableBlurMaterials=[];const u=[3,5,7,9,11];r=Math.round(this.resolution.x/2),a=Math.round(this.resolution.y/2);for(let p=0;p<this.nMips;p++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(u[p])),this.separableBlurMaterials[p].uniforms.texSize.value=new n.Vector2(r,a),r=Math.round(r/2),a=Math.round(a/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=t,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0;const M=[1,.8,.6,.4,.2];this.compositeMaterial.uniforms.bloomFactors.value=M,this.bloomTintColors=[new n.Vector3(1,1,1),new n.Vector3(1,1,1),new n.Vector3(1,1,1),new n.Vector3(1,1,1),new n.Vector3(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,D===void 0&&console.error("THREE.UnrealBloomPass relies on CopyShader");const x=D;this.copyUniforms=n.UniformsUtils.clone(x.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new n.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:x.vertexShader,fragmentShader:x.fragmentShader,blending:n.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this._oldClearColor=new n.Color,this.oldClearAlpha=1,this.basic=new n.MeshBasicMaterial({transparent:!0}),this.fsQuad=new _(null)}dispose(){for(let e=0;e<this.renderTargetsHorizontal.length;e++)this.renderTargetsHorizontal[e].dispose();for(let e=0;e<this.renderTargetsVertical.length;e++)this.renderTargetsVertical[e].dispose();this.renderTargetBright.dispose()}setSize(e,t){let i=Math.round(e/2),s=Math.round(t/2);this.renderTargetBright.setSize(i,s);for(let r=0;r<this.nMips;r++)this.renderTargetsHorizontal[r].setSize(i,s),this.renderTargetsVertical[r].setSize(i,s),this.separableBlurMaterials[r].uniforms.texSize.value=new n.Vector2(i,s),i=Math.round(i/2),s=Math.round(s/2)}render(e,t,i,s,r){window.spector&&window.spector.setMarker("Effect: Bloom"),e.getClearColor(this._oldClearColor),this.oldClearAlpha=e.getClearAlpha();const a=e.autoClear;e.autoClear=!1,e.setClearColor(this.clearColor,0),r&&e.state.buffers.stencil.setTest(!1),this.renderToScreen&&(this.fsQuad.material=this.basic,this.basic.map=i.texture,e.setRenderTarget(null),e.clear(),this.fsQuad.render(e)),this.highPassUniforms.tDiffuse.value=i.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.fsQuad.material=this.materialHighPassFilter,e.setRenderTarget(this.renderTargetBright),e.clear(),this.fsQuad.render(e);let l=this.renderTargetBright;for(let u=0;u<this.nMips;u++)this.fsQuad.material=this.separableBlurMaterials[u],this.separableBlurMaterials[u].uniforms.colorTexture.value=l.texture,this.separableBlurMaterials[u].uniforms.direction.value=F.BlurDirectionX,e.setRenderTarget(this.renderTargetsHorizontal[u]),e.clear(),this.fsQuad.render(e),this.separableBlurMaterials[u].uniforms.colorTexture.value=this.renderTargetsHorizontal[u].texture,this.separableBlurMaterials[u].uniforms.direction.value=F.BlurDirectionY,e.setRenderTarget(this.renderTargetsVertical[u]),e.clear(),this.fsQuad.render(e),l=this.renderTargetsVertical[u];this.fsQuad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,e.setRenderTarget(this.renderTargetsHorizontal[0]),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,r&&e.state.buffers.stencil.setTest(!0),this.renderToScreen?(e.setRenderTarget(null),this.fsQuad.render(e)):(e.setRenderTarget(i),this.fsQuad.render(e)),e.setClearColor(this._oldClearColor,this.oldClearAlpha),e.autoClear=a}getSeperableBlurMaterial(e){return new n.ShaderMaterial({defines:{KERNEL_RADIUS:e,SIGMA:e},uniforms:{colorTexture:{value:null},texSize:{value:new n.Vector2(.5,.5)},direction:{value:new n.Vector2(.5,.5)}},vertexShader:`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = vec4( position, 1.0 );
				}`,fragmentShader:`#include <common>
				varying vec2 vUv;
				uniform sampler2D colorTexture;
				uniform vec2 texSize;
				uniform vec2 direction;

				float gaussianPdf(in float x, in float sigma) {
					return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;
				}
				void main() {
					vec2 invSize = 1.0 / texSize;
					float fSigma = float(SIGMA);
					float weightSum = gaussianPdf(0.0, fSigma);
					vec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;
					for( int i = 1; i < KERNEL_RADIUS; i ++ ) {
						float x = float(i);
						float w = gaussianPdf(x, fSigma);
						vec2 uvOffset = direction * invSize * x;
						vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);
						vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);
						diffuseSum += (sample1 + sample2) * w;
						weightSum += 2.0 * w;
					}
					gl_FragColor = vec4(diffuseSum/weightSum);
				}`})}getCompositeMaterial(e){return new n.ShaderMaterial({defines:{NUM_MIPS:e},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:`varying vec2 vUv;
				void main() {
					vUv = uv;
					gl_Position = vec4( position, 1.0 );
				}`,fragmentShader:`varying vec2 vUv;
				uniform sampler2D blurTexture1;
				uniform sampler2D blurTexture2;
				uniform sampler2D blurTexture3;
				uniform sampler2D blurTexture4;
				uniform sampler2D blurTexture5;
				uniform sampler2D dirtTexture;
				uniform float bloomStrength;
				uniform float bloomRadius;
				uniform float bloomFactors[NUM_MIPS];
				uniform vec3 bloomTintColors[NUM_MIPS];

				float lerpBloomFactor(const in float factor) {
					float mirrorFactor = 1.2 - factor;
					return mix(factor, mirrorFactor, bloomRadius);
				}

				void main() {
					gl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +
						lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +
						lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +
						lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +
						lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );
				}`})}}F.BlurDirectionX=new n.Vector2(1,0),F.BlurDirectionY=new n.Vector2(0,1);class he{constructor(e,t,i,s=null){this.gui=s,e.type==="bloom"&&this.initBloom(e,t,i,s)}initBloom(e,t,i,s){const r=new de(t,i);r.renderToScreen=!1,r.swapBuffers();const a=new F(new THREE.Vector2(i.width,i.height),e.bloomStrength,e.bloomRadius,e.bloomThreshold);a.needsSwap=!1,r.addPass(a);const l=new O(D);l.needsSwap=!1,r.addPass(l),s&&(s.add(e,"exposure",.1,e.exposure).onChange(function(u){t.toneMappingExposure=Math.pow(u,4)}),s.add(e,"bloomThreshold",0,1).onChange(function(u){a.threshold=Number(u)}),s.add(e,"bloomStrength",0,5).onChange(function(u){a.strength=Number(u)}),s.add(e,"bloomRadius",0,2).step(.01).onChange(function(u){a.radius=Number(u)})),this.renderer=t,this.composer=r}render(){this.renderer.xr.enabled=!1,window.spector&&window.spector.setMarker("Post processing"),this.composer.render(),window.spector&&window.spector.setMarker("END: Post processing"),this.renderer.xr.enabled=!0}resize(e,t){this.composer.setSize(e,t)}dispose(){this.composer.renderTarget2.dispose(),this.composer.copyPass.dispose(),this.composer.passes.forEach(e=>{e.dispose()}),this.gui&&this.gui.destroy()}}n.ColorManagement.enabled=!0;class k{constructor(e){if(k.Instance)return k.Instance;k.Instance=this,this.config=e,this.config==null&&(this.config={gui:null}),this.devicePixelRatioMax=window.devicePixelRatio;const t=window.innerWidth,i=window.innerHeight,s=Math.min(window.devicePixelRatio,this.devicePixelRatioMax);this.res=new n.Vector2(t,i),this.resRetina=new n.Vector2(t*s,i*s),console.log("devicePixelRatio: "+window.devicePixelRatio+". Reducing to devicePixelRatioMax: "+s),this.play=1,this.time=0,this.clock=new n.Clock(!1),this.contents=[],this.contentConfigOriginal=[],this.contentConfigCurrent=[],this.contentConfigInside=null,this.contentFaceOverrides=[],this.cameraInsideCube={inside:!1,insideChanged:!1,insideFaceIndex:-1,px:!1,nx:!1,py:!1,ny:!1,pz:!1,nz:!1},this.renderOverrideFunc=null,this.resizeOverrideFunc=null,this.clippingPlanesEmpty=Object.freeze([]),this.clippingPlanesCube=[];const r=g.getFaceNormals();for(let a=0;a<r.length;a++){const l=r[a],u=new n.Plane(l,.51);this.clippingPlanesCube.push(u)}this.saveImageFlag=!1,this.init(this.config),this.render()}init(e){const{canvas:t,renderer:i,camera:s,scene:r,cameraTexture:a}=e;this.canvas=t||document.createElement("canvas"),this.canvas.id="ej-renderer";let l=this.canvas.getContext("webgl2");i!=null?this.renderer=i:(this.renderer=new n.WebGLRenderer({canvas:this.canvas,context:l,alpha:!0,antialias:!0}),this.renderer.setSize(this.res.x,this.res.y),this.renderer.setPixelRatio(this.resRetina.x/this.res.x),this.renderer.setClearColor(0,0),this.renderer.autoClear=!1,this.renderer.clippingPlanes=this.clippingPlanesEmpty,this.renderer.xr.enabled=!0,this.renderer.outputEncoding=n.sRGBEncoding,this.renderer.toneMapping=n.NoToneMapping,this.renderer.toneMappingExposure=1,this.renderer.useLegacyLights=!1),t||document.body.appendChild(this.renderer.domElement),s!=null?this.camera=s:(this.camera=new n.PerspectiveCamera(20,this.res.x/this.res.y,.01,1e3),this.camera.position.set(0,0,5),this.camera.lookAt(0,0,0)),this.camera.name="xrCamera",this.cameraTestMesh=null,this.cameraTest=this.camera,this.orbitControls=new J.OrbitControls(this.camera,this.renderer.domElement),this.orbitControls.enableDamping=!0,this.orbitControls.minDistance=0,this.orbitControls.maxDistance=10,r!=null?this.scene=r:(this.scene=new n.Scene,this.scene.background=null),a!=null?this.cameraTexture=a:this.cameraTexture=null,this.initCommon(),this.cubeInit(P),this.inputEventsInit(),window.addEventListener("resize",this.resizeHandler.bind(this)),this.renderer.setAnimationLoop(this.animationLoop.bind(this))}initCommon(){this.renderTargetContent=new n.WebGLRenderTarget(this.resRetina.x,this.resRetina.y,{wrapS:n.ClampToEdgeWrapping,wrapT:n.ClampToEdgeWrapping,magFilter:n.LinearFilter,minFilter:n.LinearFilter,generateMipmaps:!1,format:n.RGBAFormat,type:n.UnsignedByteType,anisotropy:n.Texture.anisotropy,encoding:n.sRGBEncoding,depthBuffer:!0,stencilBuffer:!0,samples:0}),this.renderTargetContentMasked=this.renderTargetContent.clone(),this.renderTargetMask=this.renderTargetContent.clone(),this.renderTargetContent.texture.name="EJ.renderTargetContent",this.renderTargetContentMasked.texture.name="EJ.renderTargetContentMasked",this.renderTargetMask.texture.name="EJ.renderTargetMask",this.renderTargets=[this.renderTargetContent,this.renderTargetContentMasked,this.renderTargetMask],this.cubeMasterOpacity=1,this.cubeMasterOpacitySaved=1,this.cubeContainer=new n.Object3D,this.scene.add(this.cubeContainer),this.cubeMask=new re(new n.Object3D,null),this.cubeMaskScene=new n.Scene,this.cubeMaskScene.add(this.cubeMask.container),this.cubeMaskPass=this.initMaskPass(),this.cubeMaskPassCamera=new n.OrthographicCamera(-1,1,1,-1,0,1),this.loadingManager=new THREE.LoadingManager,this.postProcessing=null}initMaskPass(){const e=new n.PlaneGeometry(2,2),t=new n.ShaderMaterial({uniforms:{texContent:{type:"t",value:this.renderTargetContent.texture},texMask:{type:"t",value:this.renderTargetMask.texture},color:{value:new n.Vector3(0,0,0)}},vertexShader:`
        varying vec2 vUv;
        void main(){ 
          vUv = uv;
          gl_Position = vec4( position, 1.0 );
        }
      `,fragmentShader:`
        uniform sampler2D texContent;
        uniform sampler2D texMask;
        uniform vec3 color;
        varying vec2 vUv;
        
        void main(){
          vec4 colorMask = texture2D( texMask, vUv);
          if(colorMask.r == color.r && colorMask.g == color.g && colorMask.b == color.b) {
            gl_FragColor = texture2D( texContent, vUv);
            return;
          }
          discard;
        }
      `}),i=new n.Mesh(e,t);return i.name="EJPlayer_MaskPassMesh",i.frustumCulled=!1,i}animationLoop(e,t){if(this.renderOverrideFunc!==null){this.renderOverrideFunc(e,t);return}this.render(e,t)}render(e,t){this.clock.running==!1&&this.clock.start();let i=this.clock.getDelta();i*=this.play,this.time+=i,this.orbitControls&&this.orbitControls.update(),this.cameraTestMesh||(this.cameraTestMesh=new n.Mesh,this.cameraTestMesh.frustumCulled=!1,this.cameraTestMesh.onBeforeRender=(v,w,C,B,b,H)=>{this.cameraTest=C}),this.renderer.render(this.cameraTestMesh,this.camera),this.envUpdate(),this.cubeUpdate(this.cameraTest);const s=new n.Matrix4;s.copy(this.cubeContainer.matrixWorld).invert();const r=new n.Vector3(this.cameraTest.position.x,this.cameraTest.position.y,this.cameraTest.position.z);r.applyMatrix4(s);const a=.5,l=a+.1,u=r.x<=a,M=r.x>=-a,x=r.y<=a,p=r.y>=-a,h=r.z<=a,m=r.z>=-a,f=u&&M&&x&&p&&h&&m,c=r.x<=l&&r.x>=-l&&r.y<=l&&r.y>=-l&&r.z<=l&&r.z>=-l;this.cameraInsideCube.insideChanged=this.cameraInsideCube.inside!=f,this.cameraInsideCube.inside=f,this.cameraInsideCube.insidePad=c,this.cameraInsideCube.insideChanged&&this.cameraInsideCube.inside&&(this.cameraInsideCube.px!=u?this.cameraInsideCube.insideFaceIndex=1:this.cameraInsideCube.nx!=M?this.cameraInsideCube.insideFaceIndex=3:this.cameraInsideCube.py!=x?this.cameraInsideCube.insideFaceIndex=4:this.cameraInsideCube.ny!=p?this.cameraInsideCube.insideFaceIndex=5:this.cameraInsideCube.pz!=h?this.cameraInsideCube.insideFaceIndex=0:this.cameraInsideCube.nz!=m&&(this.cameraInsideCube.insideFaceIndex=2)),this.cameraInsideCube.px=u,this.cameraInsideCube.nx=M,this.cameraInsideCube.py=x,this.cameraInsideCube.ny=p,this.cameraInsideCube.pz=h,this.cameraInsideCube.nz=m;const d=this.contentCurrent();d?this.renderContent(d):this.renderer.render(this.scene,this.camera)}renderContent(e){if(!e.instance)return;if(!e.instance.render){console.log("content.instance.render does not exist.");return}let t=!0;if(t=t&&!this.postProcessing,t=t&&e.instance.postProcessing,t){const c=e.instance.postProcessing();if(c){let d=null;this.config.gui&&(d=this.config.gui.addFolder("Post Processing")),this.postProcessing=new he(c,this.renderer,this.renderTargetContent,d)}}if(!this.cube){this.renderer.render(this.scene,this.camera),e.instance.update&&e.instance.update(),e.instance.render();return}const i=this.renderer.getRenderTarget();i&&this.renderer.xr.isPresenting&&this.resize(i.width,i.height,window.devicePixelRatio,!0),e.camera.copy(this.camera),e.scene.position.copy(this.cubeContainer.position),e.scene.quaternion.copy(this.cubeContainer.quaternion),e.scene.scale.copy(this.cubeContainer.scale);let s=this.renderer.clippingPlanes.length>0,r=!1;e.instance.useClippingPlanes&&(r=e.instance.useClippingPlanes()),r!==s&&(r?this.renderer.clippingPlanes=this.clippingPlanesCube:this.renderer.clippingPlanes=this.clippingPlanesEmpty);const l=g.getFaceNormals(),u=g.getFaceCentres(),M=g.getFaceCentres(),x=new n.Box2(new n.Vector2(0,0),new n.Vector2(this.resRetina.x,this.resRetina.y)),p=[],h=new n.Matrix3().getNormalMatrix(this.cubeContainer.matrixWorld);for(let c=0;c<l.length;c++)l[c].applyMatrix3(h).normalize();for(let c=0;c<u.length;c++)u[c].applyMatrix4(this.cubeContainer.matrixWorld);for(let c=0;c<6;c++)if(this.cameraTest.position.clone().sub(u[c]).dot(l[c])>0!==!1){if(this.cameraInsideCube.insidePad===!1){const w=[new n.Vector3(-.5,.5,0),new n.Vector3(.5,.5,0),new n.Vector3(.5,-.5,0),new n.Vector3(-.5,-.5,0)],C=new n.Box2;if(w.forEach(b=>{c===0||(c===1?b.applyAxisAngle(new n.Vector3(0,1,0),Math.PI*.5):c===2?b.applyAxisAngle(new n.Vector3(0,1,0),Math.PI):c===3?b.applyAxisAngle(new n.Vector3(0,1,0),-Math.PI*.5):c===4?b.applyAxisAngle(new n.Vector3(1,0,0),-Math.PI*.5):c===5&&b.applyAxisAngle(new n.Vector3(1,0,0),Math.PI*.5)),b.add(M[c]),b.applyMatrix4(this.cubeContainer.matrixWorld),b.project(this.cameraTest),b.x=(b.x+1)*this.resRetina.x*.5,b.y=-(b.y-1)*this.resRetina.y*.5,b.z=0,C.expandByPoint(new n.Vector2(b.x,b.y))}),C.intersectsBox(x)===!1)continue}p.push(c)}this.cameraInsideCube.insideChanged&&(this.cameraInsideCube.inside?this.contentConfigCurrent.forEach(c=>{c.cubeFaceIndices.find(v=>v===this.cameraInsideCube.insideFaceIndex)!==void 0&&(this.contentConfigInside=c,this.cubeMask.cubeBackMaterial.color.r=this.contentConfigInside.colorMask.x,this.cubeMask.cubeBackMaterial.color.g=this.contentConfigInside.colorMask.y,this.cubeMask.cubeBackMaterial.color.b=this.contentConfigInside.colorMask.z)}):(this.contentFaceOverrides=[],p.forEach(c=>{this.contentFaceOverrides.push({faceIndex:c,contentID:this.contentConfigInside.contentID,colorMask:this.contentConfigInside.colorMask})}),this.contentConfigInside=null));for(let c=0;c<this.contentFaceOverrides.length;c++){const d=this.contentFaceOverrides[c];p.find(w=>w===d.faceIndex)===void 0&&this.contentFaceOverrides.splice(c--,1)}const m=g.getFaceColorMasks();if(this.contentConfigOriginal=[],e.instance&&e.instance.contentPerCubeFace){const c=e.instance.contentPerCubeFace();if(c){const d=[];for(d.push({contentID:c.front?c.front:0,cubeFaceIndex:0}),d.push({contentID:c.right?c.right:0,cubeFaceIndex:1}),d.push({contentID:c.back?c.back:0,cubeFaceIndex:2}),d.push({contentID:c.left?c.left:0,cubeFaceIndex:3}),d.push({contentID:c.top?c.top:0,cubeFaceIndex:4}),d.push({contentID:c.bottom?c.bottom:0,cubeFaceIndex:5});d.length>0;){const v=d.splice(0,1)[0],w=[v.cubeFaceIndex];for(let C=0;C<d.length;C++)if(d[C].contentID===v.contentID){const b=d.splice(C--,1)[0];w.push(b.cubeFaceIndex)}this.contentConfigOriginal.push({contentID:v.contentID,cubeFaceIndices:w,colorMask:m.splice(0,1)[0]})}}}this.contentConfigOriginal.length===0&&(this.contentConfigOriginal=[{contentID:0,cubeFaceIndices:[0,1,2,3,4,5],colorMask:m[0]}]),this.contentConfigCurrent=[],this.contentConfigOriginal.forEach(c=>{this.contentConfigCurrent.push({contentID:c.contentID,cubeFaceIndices:[...c.cubeFaceIndices],colorMask:new n.Vector3().copy(c.colorMask)})}),this.contentFaceOverrides.forEach(c=>{this.contentConfigCurrent.forEach(v=>{const w=v.cubeFaceIndices.findIndex(C=>C===c.faceIndex);w!==-1&&v.cubeFaceIndices.splice(w,1)});const d=this.contentConfigCurrent.find(v=>v.contentID===c.contentID);d!==void 0&&d.cubeFaceIndices.push(c.faceIndex)}),this.contentConfigCurrent.forEach(c=>{c.cubeFaceIndices.forEach(d=>{this.cubeMask.setFaceColorMask(d,c.colorMask)})}),window.spector&&window.spector.setMarker("Render: Cube Mask Scene"),this.renderer.setRenderTarget(this.renderTargetMask),this.renderer.clear(),this.cubeContainer.matrixWorld.decompose(this.cubeMaskScene.position,this.cubeMaskScene.quaternion,this.cubeMaskScene.scale),this.renderer.render(this.cubeMaskScene,this.camera);let f=[];this.contentConfigInside?f=[this.contentConfigInside]:this.contentConfigCurrent.forEach(c=>{let d=!1;c.cubeFaceIndices.forEach(v=>{p.find(C=>C===v)!==void 0&&(d=!0)}),d&&f.push(c)}),e.instance.update&&e.instance.update();for(let c=0;c<f.length;c++){const d=f[c];window.spector&&window.spector.setMarker(`Rendering ${d.contentID}`),this.renderer.setRenderTarget(this.renderTargetContent),this.renderer.clear(),e.instance.render(d.contentID),this.postProcessing&&this.postProcessing.render(),this.cameraInsideCube.inside===!1&&this.cubeMask.cubeBackMaterial.color.setRGB(d.colorMask.x,d.colorMask.y,d.colorMask.z),this.cubeMaskPass.material.uniforms.color.value=d.colorMask,this.cubeMaskPass.material.uniformsNeedUpdate=!0,window.spector&&window.spector.setMarker("Render: Cube Mask Pass"),this.renderer.setRenderTarget(this.renderTargetContentMasked),c==0&&this.renderer.clear();const v=this.renderer.xr.enabled;this.renderer.xr.enabled=!1,this.renderer.render(this.cubeMaskPass,this.cubeMaskPassCamera),this.renderer.xr.enabled=v}this.saveImageFlag&&(this.saveImageFlag=!1,this.renderExterior()),this.renderer.setRenderTarget(i),window.spector&&window.spector.setMarker("Rendering EJPlayer scene"),this.renderer.render(this.scene,this.camera)}renderExterior(){window.spector&&window.spector.setMarker("Render: Exterior");const e=this.contentCurrent();if(!(e&&e.instance&&e.instance.render))return;const i=this.res.clone(),s=this.resRetina.x/this.res.x,r=512;this.resize(r,r,1);const a=this.renderTargetContent.clone();a.texture.name="EJ.renderTargetFace",a.texture.encoding=n.LinearEncoding,this.cubeContainer.matrix.identity(),this.cubeContainer.matrix.decompose(this.cubeContainer.position,this.cubeContainer.quaternion,this.cubeContainer.scale),this.cubeContainer.matrixWorld.decompose(this.cubeMaskScene.position,this.cubeMaskScene.quaternion,this.cubeMaskScene.scale),this.cubeContainer.matrix.decompose(e.scene.position,e.scene.quaternion,e.scene.scale);const l=this.camera.clone(),u=this.camera.clone();let M={};e.instance.contentPerCubeFace&&(M=e.instance.contentPerCubeFace());const x=g.getFaceDescriptors(),p=g.getFaceNormals(),h=g.getFaceColorMasks(),m=["pz","px","nz","nx","py","ny"];for(let f=0;f<x.length;f++){const c=.5/Math.tan(u.fov*.5*(Math.PI/180))+.5,d=p[f];d.multiplyScalar(c),u.position.copy(d),u.lookAt(0,0,0),window.spector&&window.spector.setMarker(`Cube Content ${f}`),this.camera.copy(u),e.camera.copy(u);const v=h[f];this.cubeMask.setFaceColorMask(f,v),this.cubeMask.cubeBackMaterial.color.setRGB(v.x,v.y,v.z),this.cubeMaskPass.material.uniforms.color.value=v,this.cubeMaskPass.material.uniformsNeedUpdate=!0,this.renderer.setRenderTarget(this.renderTargetMask),this.renderer.clear(),this.renderer.render(this.cubeMaskScene,u),this.renderer.setRenderTarget(this.renderTargetContent),this.renderer.clear();const w=x[f];let C=0;M[w]&&(C=M[w]),e.instance.render(C),this.renderer.setRenderTarget(this.renderTargetContentMasked),this.renderer.clear(),this.renderer.render(this.cubeMaskPass,this.cubeMaskPassCamera),this.renderer.setRenderTarget(a),this.renderer.clear(),this.renderer.render(this.cubeContainer,u);const B=new Uint8Array(r*r*4),b=new Uint8Array(r*r*4);this.renderer.readRenderTargetPixels(a,0,0,r,r,B);for(let I=0;I<r;I++){const j=I*r*4,me=(r-I-1)*r*4;b.set(B.subarray(j,j+r*4),me)}const H=m[f]+".png";this.saveImage(b,r,r,H)}a.dispose(),e.camera.copy(l),this.resize(i.x,i.y,s)}dispose(){this.inputEventsKill()}requestSaveImage(){this.saveImageFlag=!0}saveImage(e,t,i,s){const r=document.createElement("canvas");r.width=t,r.height=i;const a=r.getContext("2d"),l=a.createImageData(t,i);l.data.set(e),a.putImageData(l,0,0),r.toBlob(u=>{this.downloadImage(u,s)},"image/png")}downloadImage(e,t){let i=document.createElement("a");document.body.appendChild(i),i.download=t,i.href=URL.createObjectURL(e),i.click(),document.body.removeChild(i)}resize(e=window.innerWidth,t=window.innerHeight,i=window.devicePixelRatio,s=!1){i=Math.min(i,this.devicePixelRatioMax);const r=e*i,a=t*i;if(this.res.x==e&&this.res.y==t&&this.resRetina.x==r&&this.resRetina.y==a)return;this.res=new n.Vector2(e,t),s?this.resRetina=new n.Vector2(e,t):(this.resRetina=new n.Vector2(r,a),this.camera.aspect=this.res.x/this.res.y,this.camera.updateProjectionMatrix(),this.renderer.setSize(this.res.x,this.res.y),this.renderer.setPixelRatio(i)),this.renderTargets.forEach(u=>{u.setSize(this.resRetina.x,this.resRetina.y)});const l=this.contentCurrent();l&&l.instance&&l.instance.resize&&l.instance.resize(this.resRetina.x,this.resRetina.y),this.cubeUpdateProps(),this.postProcessing&&this.postProcessing.resize(this.resRetina.x,this.resRetina.y)}resizeHandler(){if(this.resizeOverrideFunc!==null){this.resizeOverrideFunc();return}this.resize()}inputEventsInit(){document.addEventListener("keydown",this.inputHandler.bind(this)),document.addEventListener("keyup",this.inputHandler.bind(this)),document.addEventListener("pointerdown",this.inputHandler.bind(this)),document.addEventListener("pointerup",this.inputHandler.bind(this)),document.addEventListener("pointermove",this.inputHandler.bind(this))}inputEventsKill(){document.removeEventListener("keydown",this.inputHandler.bind(this)),document.removeEventListener("keyup",this.inputHandler.bind(this)),document.removeEventListener("pointerdown",this.inputHandler.bind(this)),document.removeEventListener("pointerup",this.inputHandler.bind(this)),document.removeEventListener("pointermove",this.inputHandler.bind(this))}inputHandler(e){const t=this.contentCurrent();t&&t.instance&&t.instance[e.type]&&t.instance[e.type](e)}envKill(){this.env!=null&&(this.env.container.parent&&this.env.container.parent.remove(this.env.container),this.env=null)}envCameraInit(){this.env=new ce(new n.Object3D,this.camera,this.cameraTexture),this.scene.add(this.env.container)}envInit(e){this.envKill(),e!=ae&&(e==oe&&(this.env=new se(new n.Object3D,this.camera)),this.scene.add(this.env.container))}envUpdate(){this.env&&this.env.update()}cubeKill(){this.cube!=null&&(this.cube.dispose(),this.cube=null)}cubeInit(e){let t=!1;if(t=t||e===S,t=t||e===P,t=t||e===R,t=t||e===N,t==!1)return;let i=!0;i=i&&this.cube!=null,i=i&&this.cube.style===e,!i&&(this.cubeKill(),e!=S&&(e==P?this.cube=new X(this.cubeContainer,this.config.gui):e==R?this.cube=new Z(this.cubeContainer,this.config.gui):e==N&&(this.cube=new ne(this.cubeContainer,this.config.gui)),this.cubeUpdateProps(),this.cube.updateMasterOpacity(this.cubeMasterOpacity)))}cubeUpdate(e){if(this.cube==null)return;this.cube.update(e);const t=this.cubeMasterOpacitySaved!=this.cubeMasterOpacity;this.cubeMasterOpacitySaved=this.cubeMasterOpacity,t&&this.cube.updateMasterOpacity(this.cubeMasterOpacity)}cubeUpdateProps(){if(this.cube==null)return;let e=!1;const t=this.contentCurrent();t&&t.instance&&t.instance.canGoInsideCube&&(e=t.instance.canGoInsideCube()),this.cube.updateProps(this.renderTargetContentMasked.texture,this.resRetina,e)}contentLoaded(){const e=this.contentCurrent();return e?e.instance&&e.instance.loaded?e.instance.loaded():!0:!1}contentLoadProgress(){let e=0;const t=this.contentCurrent();return t&&t.instance&&t.instance.loadProgress&&(e=t.instance.loadProgress()),e}contentCurrent(){return this.contents.length==0?null:this.contents[this.contents.length-1]}contentDispose(e){e.instance&&e.instance.dispose&&e.instance.dispose(),e.scene&&y.disposeRecursive(e.scene),e.gui&&e.gui.destroy(),this.postProcessing&&(this.postProcessing.dispose(),this.postProcessing=null)}contentInstantiate(e){const t=this.contentCurrent();if(t==null)return;t.scene=new n.Scene,t.camera=this.camera,this.config.gui&&(t.gui=this.config.gui.addFolder("Content Settings"));const i=s=>{const r=t.filename;return r.substring(0,r.lastIndexOf("/"))+"/"+s};if(this.loadingManager.setURLModifier(i),t.instance=e.main({canvas:this.canvas,renderer:this.renderer,renderTarget:this.renderTargetContent,scene:t.scene,camera:t.camera,loadingManager:this.loadingManager,gui:t.gui}),t.instance&&t.instance.cubeStyle){const s=t.instance.cubeStyle();this.cubeInit(s)}}contentKill(e){this.contentDispose(e)}contentKillAll(){this.contents.forEach(e=>{this.contentKill(e)}),this.contents.splice(0,this.contents.length)}contentValidate(e){return!0}setContent({filename:e,module:t}){if(this.contentValidate(e)==!1)return;this.contentKillAll();const i={filename:e,identifier:e.split(".js")[0]+"-script",module:t,instance:null,scene:null,gui:null};this.contents.push(i),this.contentInstantiate(t)}setCube(e){this.cubeInit(e)}setEnvironment(e){this.envInit(e)}}typeof window<"u"&&(window.EJPlayer=k),T.EJPlayer=k,Object.defineProperty(T,Symbol.toStringTag,{value:"Module"})});
